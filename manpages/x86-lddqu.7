.nh
.TH "X86-LDDQU" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
LDDQU - LOAD UNALIGNED INTEGER 128 BITS
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32\-bit Mode\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
F2 0F F0 /mem	RM	V/V	SSE3	Load unaligned data from xmm1.
T{
VEX.128.F2.0F.WIG F0 /r VLDDQU xmm1, m128
T}
	RM	V/V	AVX	T{
Load unaligned packed integer values from mem to xmm1.
T}
T{
VEX.256.F2.0F.WIG F0 /r VLDDQU ymm1, m256
T}
	RM	V/V	AVX	T{
Load unaligned packed integer values from mem to ymm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RM	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
.TE

.SH DESCRIPTION
.PP
The instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128
for loading from memory. That is: 32/16 bytes of data starting at an
address specified by the source memory operand (second operand) are
fetched from memory and placed in a destination register (first
operand). The source operand need not be aligned on a 32/16\-byte
boundary. Up to 64/32 bytes may be loaded from memory; this is
implementation dependent.

.PP
This instruction may improve performance relative to (V)MOVDQU if the
source operand crosses a cache line boundary. In situations that require
the data loaded by (V)LDDQU be modified and stored to the same location,
use (V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double
quadword to or from memory locations that are known to be aligned on
16\-byte boundaries, use the (V)MOVDQA instruction.

.SH IMPLEMENTATION NOTES
.RS
.IP \(bu 2
If the source is aligned to a 32/16\-byte boundary, based on the
implementation, the 32/16 bytes may be loaded more than once. For
that reason, the usage of (V)LDDQU should be avoided when using
uncached or write\-combining (WC) memory regions. For uncached or WC
memory regions, keep using (V)MOVDQU.
.IP \(bu 2
This instruction is a replacement for (V)MOVDQU (load) in situations
where cache line splits significantly affect performance. It should
not be used in situations where store\-load forwarding is performance
critical. If performance of store\-load forwarding is critical to the
application, use (V)MOVDQA store\-load pairs when data is 256/128\-bit
aligned or (V)MOVDQU store\-load pairs when data is 256/128\-bit
unaligned.
.IP \(bu 2
If the memory address is not aligned on 32/16\-byte boundary, some
implementations may load up to 64/32 bytes and return 32/16 bytes in
the destination. Some processor implementations may issue multiple
loads to access the appropriate 32/16 bytes. Developers of
multi\-threaded or multi\-processor software should be aware that on
these processors the loads will be performed in a non\-atomic way.
.IP \(bu 2
If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL
= 3), an alignment\-check exception (#AC) may or may not be
generated (depending on processor implementation) when the memory
address is not aligned on an 8\-byte boundary.

.RE

.PP
In 64\-bit mode, use of the REX.R prefix permits this instruction to
access additional registers (XMM8\-XMM15).

.PP
Note: In VEX\-encoded versions, VEX.vvvv is reserved and must be 1111b
otherwise instructions will #UD.

.SH OPERATION
.SS LDDQU (128\-bit Legacy SSE version)
.PP
.RS

.nf
DEST[127:0] ← SRC[127:0]
DEST[MAXVL\-1:128] (Unmodified)

.fi
.RE

.SS VLDDQU (VEX.128 encoded version)
.PP
.RS

.nf
DEST[127:0] ← SRC[127:0]
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SS VLDDQU (VEX.256 encoded version)
.PP
.RS

.nf
DEST[255:0] ← SRC[255:0]

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
LDDQU: \_\_m128i \_mm\_lddqu\_si128 (\_\_m128i * p);

VLDDQU: \_\_m256i \_mm256\_lddqu\_si256 (\_\_m256i * p);

.fi
.RE

.SH NUMERIC EXCEPTIONS
.PP
None

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4;

.PP
Note treatment of #AC varies.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
