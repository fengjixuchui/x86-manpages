.nh
.TH "X86-EPA" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
EPA - ADD VERSION ARRAY
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
EAX = 0AH ENCLS[EPA]	IR	V/V	SGX1	T{
This leaf function adds a Version Array to the EPC.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l 
l l l l .
Op/En	EAX	RBX	RCX
IR	EPA (In)	PT\_VA (In, Constant)	T{
Effective address of the EPC page (In)
T}
.TE

.SS Description
.PP
This leaf function creates an empty version array in the EPC page whose
logical address is given by DS:RCX, and sets up EPCM attributes for that
page. At the time of execution of this instruction, the register RBX
must be set to PT\_VA.

.PP
The table below provides additional information on the memory parameter
of EPA leaf function.

.SH EPA MEMORY PARAMETER SEMANTICS
.TS
allbox;
l 
l .
EPCPAGE
T{
Write access permitted by Enclave
T}
.TE

.SS Concurrency Restrictions
.PP
Leaf

.PP
Parameter

.PP
Base Concurrency Restrictions

.PP
Access

.PP
On Conflict

.PP
SGX\_CONFLICT VM Exit Qualification

.PP
EPA

.PP
VA [DS:RCX]

.PP
Exclusive

.PP
#GP

.PP
EPC\_PAGE\_CONFLICT\_EXCEPTION

.PP
Table 40\-37\&. Base Concurrency
Restrictions of EPA

.PP
Leaf

.PP
Parameter

.PP
Additional Concurrency Restrictions

.PP
vs. EACCEPT, EACCEPTCOPY, EMODPE, EMODPR, EMODT

.PP
vs. EADD, EEXTEND, EINIT

.PP
vs. ETRACK, ETRACKC

.PP
Access

.PP
On Conflict

.PP
Access

.PP
On Conflict

.PP
Access

.PP
On Conflict

.PP
EPA

.PP
VA [DS:RCX]

.PP
Concurrent

.PP
L

.PP
Concurrent

.PP
Concurrent

.PP
Table 40\-38\&. Additional Concurrency
Restrictions of EPA

.SS Operation
.PP
.RS

.nf
IF (RBX ≠ PT\_VA or DS:RCX is not 4KByte Aligned)
    THEN #GP(0); FI;
IF (DS:RCX does not resolve within an EPC)
    THEN #PF(DS:RCX); FI;
(* Check concurrency with other Intel SGX instructions *)
IF (Other Intel SGX instructions accessing the page)
    THEN
        IF (<<VMX non\-root operation>> AND <<ENABLE\_EPC\_VIRTUALIZATION\_EXTENSIONS>>)
            THEN
                VMCS.Exit\_reason ← SGX\_CONFLICT;
                VMCS.Exit\_qualification.code ← EPC\_PAGE\_CONFLICT\_EXCEPTION;
                VMCS.Exit\_qualification.error ← 0;
                VMCS.Guest\-physical\_address ←<< translation of DS:RCX produced by paging >>;
                VMCS.Guest\-linear\_address ← DS:RCX;
            Deliver VMEXIT;
            ELSE
                #GP(0);
        FI;
FI;
(* Check EPC page must be empty *)
IF (EPCM(DS:RCX). VALID ≠ 0)
    THEN #PF(DS:RCX); FI;
(* Clears EPC page *)
DS:RCX[32767:0] ← 0;
EPCM(DS:RCX).PT ← PT\_VA;
EPCM(DS:RCX).ENCLAVEADDRESS ← 0;
EPCM(DS:RCX).BLOCKED ← 0;
EPCM(DS:RCX).PENDING ← 0;
EPCM(DS:RCX).MODIFIED ← 0;
EPCM(DS:RCX).PR ← 0;
EPCM(DS:RCX).RWX ← 0;
EPCM(DS:RCX).VALID ← 1;

.fi
.RE

.SS Flags Affected
.PP
None

.SS Protected Mode Exceptions
.PP
#GP(0)

.PP
If a memory operand effective address is outside the DS segment limit.

.PP
If a memory operand is not properly aligned.

.PP
If another Intel SGX instruction is accessing the EPC page.

.PP
If RBX is not set to PT\_VA.

.PP
#PF(error

.PP
code) If a page fault occurs in accessing memory operands.

.PP
If a memory operand is not an EPC page.

.PP
If the EPC page is valid.

.SS 64\-Bit Mode Exceptions
.PP
#GP(0)

.PP
If a memory operand is non\-canonical form.

.PP
If a memory operand is not properly aligned.

.PP
If another Intel SGX instruction is accessing the EPC page.

.PP
If RBX is not set to PT\_VA.

.PP
#PF(error

.PP
code) If a page fault occurs in accessing memory operands.

.PP
If a memory operand is not an EPC page.

.PP
If the EPC page is valid.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
