.nh
.TH "X86-FINIT-FNINIT" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
FINIT-FNINIT - INITIALIZE FLOATING-POINT UNIT
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fC64\-Bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
9B DB E3	FINIT	Valid	Valid	T{
Initialize FPU after checking for pending unmasked floating\-point exceptions.
T}
DB E3	FNINIT*	Valid	Valid	T{
Initialize FPU without checking for pending unmasked floating\-point exceptions.
T}
.TE

.PP
.RS

.PP
* SeeIA\-32ArchitectureCompatibilitysectionbelow.

.RE

.SH DESCRIPTION
.PP
Sets the FPU control, status, tag, instruction pointer, and data pointer
registers to their default states. The FPU control word is set to 037FH
(round to nearest, all exceptions masked, 64\-bit precision). The status
word is cleared (no exception flags set, TOP is set to 0). The data
registers in the register stack are left unchanged, but they are all
tagged as empty (11B). Both the instruction and data pointers are
cleared.

.PP
The FINIT instruction checks for and handles any pending unmasked
floating\-point exceptions before performing the initialization; the
FNINIT instruction does not.

.PP
The assembler issues two instructions for the FINIT instruction (an
FWAIT instruction followed by an FNINIT instruction), and the processor
executes each of these instructions in separately. If an exception is
generated for either of these instructions, the save EIP points to the
instruction that caused the exception.

.PP
This instruction’s operation is the same in non\-64\-bit modes and 64\-bit
mode.

.SH IA\-32 ARCHITECTURE COMPATIBILITY
.PP
When operating a Pentium or Intel486 processor in MS\-DOS compatibility
mode, it is possible (under unusual circumstances) for an FNINIT
instruction to be interrupted prior to being executed to handle a
pending FPU exception. See the section titled “No\-Wait FPU Instructions
Can Get FPU Interrupt in Window” in Appendix D of the Intel® 64 and
IA\-32 Architectures Software Developer’s Manual, Volume 1, for a
description of these circumstances. An FNINIT instruction cannot be
interrupted in this way on later Intel processors, except for the Intel
QuarkTM X1000 processor.

.PP
In the Intel387 math coprocessor, the FINIT/FNINIT instruction does not
clear the instruction and data pointers.

.PP
This instruction affects only the x87 FPU. It does not affect the XMM
and MXCSR registers.

.SH OPERATION
.PP
.RS

.nf
FPUControlWord ← 037FH;
FPUStatusWord ← 0;
FPUTagWord ← FFFFH;
FPUDataPointer ← 0;
FPUInstructionPointer ← 0;
FPULastInstructionOpcode ← 0;

.fi
.RE

.SH FPU FLAGS AFFECTED
.TS
allbox;
l l 
l l .
C0, C1, C2, C3	set to 0.
.TE

.SH FLOATING\-POINT EXCEPTIONS
.PP
None

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#NM	CR0.EM
[
bit 2
]
 or CR0.TS
[
bit 3
]
 = 1.
#MF	T{
If there is a pending x87 FPU exception.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
