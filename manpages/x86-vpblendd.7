.nh
.TH "X86-VPBLENDD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VPBLENDD - BLEND PACKED DWORDS
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 \-bit Mode\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
VEX.128.66.0F3A.W0 02 /r ib VPBLENDD xmm1, xmm2, xmm3/m128, imm8
T}
	RVMI	V/V	AVX2	Select dwords from xmm1.
T{
VEX.256.66.0F3A.W0 02 /r ib VPBLENDD ymm1, ymm2, ymm3/m256, imm8
T}
	RVMI	V/V	AVX2	Select dwords from ymm1.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RVMI	ModRM:reg (w)	VEX.vvvv	ModRM:r/m (r)	Imm8
.TE

.SH DESCRIPTION
.PP
Dword elements from the source operand (second operand) are
conditionally written to the destination operand (first operand)
depending on bits in the immediate operand (third operand). The
immediate bits (bits 7:0) form a mask that determines whether the
corresponding word in the destination is copied from the source. If a
bit in the mask, corresponding to a word, is “1", then the word is
copied, else the word is unchanged.

.PP
VEX.128 encoded version: The second source operand can be an XMM
register or a 128\-bit memory location. The first source and destination
operands are XMM registers. Bits (MAXVL\-1:128) of the corresponding YMM
register are zeroed.

.PP
VEX.256 encoded version: The first source operand is a YMM register. The
second source operand is a YMM register or a 256\-bit memory location.
The destination operand is a YMM register.

.SH OPERATION
.SS VPBLENDD (VEX.256 encoded version)
.PP
.RS

.nf
IF (imm8[0] == 1) THEN DEST[31:0]←SRC2[31:0]
ELSE DEST[31:0]←SRC1[31:0]
IF (imm8[1] == 1) THEN DEST[63:32]←SRC2[63:32]
ELSE DEST[63:32]←SRC1[63:32]
IF (imm8[2] == 1) THEN DEST[95:64]←SRC2[95:64]
ELSE DEST[95:64]←SRC1[95:64]
IF (imm8[3] == 1) THEN DEST[127:96]←SRC2[127:96]
ELSE DEST[127:96]←SRC1[127:96]
IF (imm8[4] == 1) THEN DEST[159:128]←SRC2[159:128]
ELSE DEST[159:128]←SRC1[159:128]
IF (imm8[5] == 1) THEN DEST[191:160]←SRC2[191:160]
ELSE DEST[191:160]←SRC1[191:160]
IF (imm8[6] == 1) THEN DEST[223:192]←SRC2[223:192]
ELSE DEST[223:192]←SRC1[223:192]
IF (imm8[7] == 1) THEN DEST[255:224]←SRC2[255:224]
ELSE DEST[255:224]←SRC1[255:224]

.fi
.RE

.SS VPBLENDD (VEX.128 encoded version)
.PP
.RS

.nf
IF (imm8[0] == 1) THEN DEST[31:0]←SRC2[31:0]
ELSE DEST[31:0]←SRC1[31:0]
IF (imm8[1] == 1) THEN DEST[63:32]←SRC2[63:32]
ELSE DEST[63:32]←SRC1[63:32]
IF (imm8[2] == 1) THEN DEST[95:64]←SRC2[95:64]
ELSE DEST[95:64]←SRC1[95:64]
IF (imm8[3] == 1) THEN DEST[127:96]←SRC2[127:96]
ELSE DEST[127:96]←SRC1[127:96]
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
VPBLENDD: \_\_m128i \_mm\_blend\_epi32 (\_\_m128i v1, \_\_m128i v2, const int mask)

VPBLENDD: \_\_m256i \_mm256\_blend\_epi32 (\_\_m256i v1, \_\_m256i v2, const int mask)

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4; additionally

.TS
allbox;
l l 
l l .
#UD	If VEX.W = 1.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
