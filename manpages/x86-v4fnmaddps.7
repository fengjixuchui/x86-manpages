.nh
.TH "X86-V4FMADDPS-V4FNMADDPS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
V4FMADDPS-V4FNMADDPS - PACKED SINGLE-PRECISION FLOATING-POINT FUSED MULTIPLY-ADD (4-ITERATIONS)
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
EVEX.512.F2.0F38.W0 9A /r V4FMADDPS zmm1{k1}{z}, zmm2+3, m128
T}
	A	V/V	AVX512\_4FMAPS	T{
Multiply packed single\-precision floating\-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1.
T}
T{
EVEX.512.F2.0F38.W0 AA /r V4FNMADDPS zmm1{k1}{z}, zmm2+3, m128
T}
	A	V/V	AVX512\_4FMAPS	T{
Multiply and negate packed single\-precision floating\-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l 
l .
T{
Op/En Tuple Operand 1 Operand 2 Operand 3 Operand 4
T}
A Tuple1
\_
T{
4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA
T}
.TE

.SS Description
.PP
This instruction computes 4 sequential packed fused single\-precision
floating\-point multiply\-add instructions with a sequentially selected
memory operand in each of the four steps.

.PP
In the above box, the notation of “+3” is used to denote that the
instruction accesses 4 source registers based on that operand; sources
are consecutive, start in a multiple of 4 boundary, and contain the
encoded register operand.

.PP
This instruction supports memory fault suppression. The entire memory
operand is loaded if any of the 16 lowest significant mask bits is set
to 1 or if a “no masking” encoding is used.

.PP
The tuple type Tuple1\_4X implies that four 32\-bit elements (16 bytes)
are referenced by the memory operation portion of this instruction.

.PP
Rounding is performed at every FMA (fused multiply and add) boundary.
Exceptions are also taken sequentially. Pre\- and post\-computational
exceptions of the first FMA take priority over the pre\- and
post\-computational exceptions of the second FMA, etc.

.SS Operation
.PP
.RS

.nf
src\_reg\_id is the 5 bit index of the vector register specified in the instruction as the src1 register.
define NFMA\_PS(kl, vl, dest, k1, msrc, regs\_loaded, src\_base, posneg):
    tmpdest ← dest
    // reg[] is an array representing the SIMD register file.
    FOR j ← 0 to regs\_loaded\-1:
        FOR i ← 0 to kl\-1:
            IF k1[i] or *no writemask*:
                IF posneg = 0:
                    tmpdest.single[i] ← RoundFPControl\_MXCSR(tmpdest.single[i] \- reg[src\_base + j ].single[i] * msrc.single[j])
            ELSE:
                    tmpdest.single[i] ← RoundFPControl\_MXCSR(tmpdest.single[i] + reg[src\_base + j ].single[i] * msrc.single[j])
        ELSE IF *zeroing*:
            tmpdest.single[i] ← 0
    dest ← tmpdst
    dest[MAX\_VL\-1:VL] ← 0
V4FMADDPS and V4FNMADDPS dest{k1}, src1, msrc (AVX512)
KL, VL = (16,512)
regs\_loaded ← 4
src\_base ← src\_reg\_id \& \~3 // for src1 operand
posneg ← 0 if negative form, 1 otherwise
NFMA\_PS(kl, vl, dest, k1, msrc, regs\_loaded, src\_base, posneg)

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
V4FMADDPS \_\_m512 \_mm512\_4fmadd\_ps( \_\_m512, \_\_m512x4, \_\_m128 *);

V4FMADDPS \_\_m512 \_mm512\_mask\_4fmadd\_ps(\_\_m512, \_\_mmask16, \_\_m512x4, \_\_m128 *);

V4FMADDPS \_\_m512 \_mm512\_maskz\_4fmadd\_ps(\_\_mmask16, \_\_m512, \_\_m512x4, \_\_m128 *);

V4FNMADDPS \_\_m512 \_mm512\_4fnmadd\_ps(\_\_m512, \_\_m512x4, \_\_m128 *);

V4FNMADDPS \_\_m512 \_mm512\_mask\_4fnmadd\_ps(\_\_m512, \_\_mmask16, \_\_m512x4, \_\_m128 *);

V4FNMADDPS \_\_m512 \_mm512\_maskz\_4fnmadd\_ps(\_\_mmask16, \_\_m512, \_\_m512x4, \_\_m128 *);

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
Overflow, Underflow, Invalid, Precision, Denormal.

.SS Other Exceptions
.PP
See Type E2; additionally

.TS
allbox;
l l 
l l .
#UD	T{
If the EVEX broadcast bit is set to 1.
T}
#UD	If the MODRM.mod = 0b11.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
