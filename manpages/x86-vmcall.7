.nh
.TH "X86-VMCALL" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VMCALL - CALL TO VM MONITOR
.TS
allbox;
l l l 
l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fCDescription\fR
0F 01 C1 VMCALL	ZO	T{
Call to VM monitor by causing VM exit.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
ZO	NA	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
This instruction allows guest software can make a call for service into
an underlying VM monitor. The details of the programming interface for
such calls are VMM\-specific; this instruction does nothing more than
cause a VM exit, registering the appropriate exit reason.

.PP
Use of this instruction in VMX root operation invokes an SMM monitor
(see Section 34.15.2). This invocation will activate the dual\-monitor
treatment of system\-management interrupts (SMIs) and system\-management
mode (SMM) if it is not already active (see Section 34.15.6).

.SH OPERATION
.PP
.RS

.nf
IF not in VMX operation
    THEN #UD;
ELSIF in VMX non\-root operation
    THEN VM exit;
ELSIF (RFLAGS.VM = 1) or (IA32\_EFER.LMA = 1 and CS.L = 0)
    THEN #UD;
ELSIF CPL > 0
    THEN #GP(0);
ELSIF in SMM or the logical processor does not support the dual\-monitor treatment of SMIs and SMM or the valid bit in the
IA32\_SMM\_MONITOR\_CTL MSR is clear
    THEN VMfail (VMCALL executed in VMX root operation);
ELSIF dual\-monitor treatment of SMIs and SMM is active
    THEN perform an SMM VM exit (see Section 34.15.2);
ELSIF current\-VMCS pointer is not valid
    THEN VMfailInvalid;
ELSIF launch state of current VMCS is not clear
    THEN VMfailValid(VMCALL with non\-clear VMCS);
ELSIF VM\-exit control fields are not valid (see Section 34.15.6.1)
    THEN VMfailValid (VMCALL with invalid VM\-exit control fields);
ELSE
    enter SMM;
    read revision identifier in MSEG;
    IF revision identifier does not match that supported by processor
        THEN
            leave SMM;
            VMfailValid(VMCALL with incorrect MSEG revision identifier);
        ELSE
            read SMM\-monitor features field in MSEG (see Section 34.15.6.1);
            IF features field is invalid
                THEN
                    leave SMM;
                    VMfailValid(VMCALL with invalid SMM\-monitor features);
                ELSE activate dual\-monitor treatment of SMIs and SMM (see Section 34.15.6);
            FI;
        FI;
FI;

.fi
.RE

.SH FLAGS AFFECTED
.PP
See the operation section and Section 30.2.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If the current privilege level is not 0 and the logical processor is in VMX root operation.
T}
#UD	T{
If executed outside VMX operation.
T}
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
If executed outside VMX operation.
T}
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
If executed outside VMX non\-root operation.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
If executed outside VMX non\-root operation.
T}
.TE

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
If executed outside VMX operation.
T}
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
