.nh
.TH "X86-VCVTUSI2SS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VCVTUSI2SS - CONVERT UNSIGNED INTEGER TO SCALAR SINGLE-PRECISION FLOATING-POINT VALUE
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
EVEX.LIG.F3.0F.W0 7B /r VCVTUSI2SS xmm1, xmm2, r/m32{er}
T}
	A	V/V	AVX512F	T{
Convert one signed doubleword integer from r/m32 to one single\-precision floating\-point value in xmm1.
T}
T{
EVEX.LIG.F3.0F.W1 7B /r VCVTUSI2SS xmm1, xmm2, r/m64{er}
T}
	A	V/N.E.1	AVX512F	T{
Convert one signed quadword integer from r/m64 to one single\-precision floating\-point value in xmm1.
T}
.TE

.PP
.RS

.PP
1\&. For this specific instruction, EVEX.W in non\-64 bit is ignored;
the instructions behaves as if the W0 version is used.

.RE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	Tuple1 Scalar	ModRM:reg (w)	VEX.vvvv	ModRM:r/m (r)	NA
.TE

.SS Description
.PP
Converts a unsigned doubleword integer (or unsigned quadword integer if
operand size is 64 bits) in the source operand (second operand) to a
single\-precision floating\-point value in the destination operand (first
operand). The source operand can be a general\-purpose register or a
memory location. The destination operand is an XMM register. The result
is stored in the low doubleword of the destination operand. When a
conversion is inexact, the value returned is rounded according to the
rounding control bits in the MXCSR register or the embedded rounding
control bits.

.PP
The second source operand can be a general\-purpose register or a
32/64\-bit memory location. The first source and destination operands are
XMM registers. Bits (127:32) of the XMM register destination are copied
from corresponding bits in the first source operand. Bits (MAXVL\-1:128)
of the destination register are zeroed.

.PP
EVEX.W1 version: promotes the instruction to use 64\-bit input value in
64\-bit mode.

.SS Operation
.SS VCVTUSI2SS (EVEX encoded version)
.PP
.RS

.nf
IF (SRC2 *is register*) AND (EVEX.b = 1)
    THEN
        SET\_RM(EVEX.RC);
    ELSE
        SET\_RM(MXCSR.RM);
FI;
IF 64\-Bit Mode And OperandSize = 64
THEN
    DEST[31:0] ← Convert\_UInteger\_To\_Single\_Precision\_Floating\_Point(SRC[63:0]);
ELSE
    DEST[31:0] ← Convert\_UInteger\_To\_Single\_Precision\_Floating\_Point(SRC[31:0]);
FI;
DEST[127:32] ← SRC1[127:32]
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
VCVTUSI2SS \_\_m128 \_mm\_cvtu32\_ss( \_\_m128 s, unsigned a);

VCVTUSI2SS \_\_m128 \_mm\_cvt\_roundu32\_ss( \_\_m128 s, unsigned a, int r);

VCVTUSI2SS \_\_m128 \_mm\_cvtu64\_ss( \_\_m128 s, unsigned \_\_int64 a);

VCVTUSI2SS \_\_m128 \_mm\_cvt\_roundu64\_ss( \_\_m128 s, unsigned \_\_int64 a, int r);

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
Precision

.SS Other Exceptions
.PP
See Exceptions Type E3NF.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
