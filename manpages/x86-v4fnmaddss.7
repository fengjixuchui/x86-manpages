.nh
.TH "X86-V4FMADDSS-V4FNMADDSS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
V4FMADDSS-V4FNMADDSS - SCALAR SINGLE-PRECISION FLOATING-POINT FUSED MULTIPLY-ADD (4-ITERATIONS)
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
EVEX.LLIG.F2.0F38.W0 9B /r V4FMADDSS xmm1{k1}{z}, xmm2+3, m128
T}
	A	V/V	AVX512\_4FMAPS	T{
Multiply scalar single\-precision floating\-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1.
T}
T{
EVEX.LLIG.F2.0F38.W0 AB /r V4FNMADDSS xmm1{k1}{z}, xmm2+3, m128
T}
	A	V/V	AVX512\_4FMAPS	T{
Multiply and negate scalar single\-precision floating\-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l 
l .
T{
Op/En Tuple Operand 1 Operand 2 Operand 3 Operand 4
T}
A Tuple1
\_
T{
4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA
T}
.TE

.SS Description
.PP
This instruction computes 4 sequential scalar fused single\-precision
floating\-point multiply\-add instructions with a sequentially selected
memory operand in each of the four steps.

.PP
In the above box, the notation of “+3” is used to denote that the
instruction accesses 4 source registers based that operand; sources are
consecutive, start in a multiple of 4 boundary, and contain the encoded
register operand.

.PP
This instruction supports memory fault suppression. The entire memory
operand is loaded if the least significant mask bit is set to 1 or if a
“no masking” encoding is used.

.PP
The tuple type Tuple1\_4X implies that four 32\-bit elements (16 bytes)
are referenced by the memory operation portion of this instruction.

.PP
Rounding is performed at every FMA boundary. Exceptions are also taken
sequentially. Pre\- and post\-computational exceptions of the first FMA
take priority over the pre\- and post\-computational exceptions of the
second FMA, etc.

.SS Operation
.PP
.RS

.nf
src\_reg\_id is the 5 bit index of the vector register specified in the instruction as the src1 register.
define NFMA\_SS(vl, dest, k1, msrc, regs\_loaded, src\_base, posneg):
    tmpdest ← dest
    // reg[] is an array representing the SIMD register file.
    IF k1[0] or *no writemask*:
        FOR j ← 0 to regs\_loaded \- 1:
            IF posneg = 0:
                tmpdest.single[0] ← RoundFPControl\_MXCSR(tmpdest.single[0] \- reg[src\_base + j ].single[0] * msrc.single[j])
            ELSE:
                tmpdest.single[0] ← RoundFPControl\_MXCSR(tmpdest.single[0] + reg[src\_base + j ].single[0] * msrc.single[j])
    ELSE IF *zeroing*:
        tmpdest.single[0] ← 0
    dest ← tmpdst
    dest[MAX\_VL\-1:VL] ← 0
V4FMADDSS and V4FNMADDSS dest{k1}, src1, msrc (AVX512)
VL = 128
regs\_loaded ← 4
src\_base ← src\_reg\_id \& \~3 // for src1 operand
posneg ← 0 if negative form, 1 otherwise
NFMA\_SS(vl, dest, k1, msrc, regs\_loaded, src\_base, posneg)

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
V4FMADDSS \_\_m128 \_mm\_4fmadd\_ss(\_\_m128, \_\_m128x4, \_\_m128 *);

V4FMADDSS \_\_m128 \_mm\_mask\_4fmadd\_ss(\_\_m128, \_\_mmask8, \_\_m128x4, \_\_m128 *);

V4FMADDSS \_\_m128 \_mm\_maskz\_4fmadd\_ss(\_\_mmask8, \_\_m128, \_\_m128x4, \_\_m128 *);

V4FNMADDSS \_\_m128 \_mm\_4fnmadd\_ss(\_\_m128, \_\_m128x4, \_\_m128 *);

V4FNMADDSS \_\_m128 \_mm\_mask\_4fnmadd\_ss(\_\_m128, \_\_mmask8, \_\_m128x4, \_\_m128 *);

V4FNMADDSS \_\_m128 \_mm\_maskz\_4fnmadd\_ss(\_\_mmask8, \_\_m128, \_\_m128x4, \_\_m128 *);

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
Overflow, Underflow, Invalid, Precision, Denormal.

.SS Other Exceptions
.PP
See Type E2; additionally

.TS
allbox;
l l 
l l .
#UD	T{
If the EVEX broadcast bit is set to 1.
T}
#UD	If the MODRM.mod = 0b11.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
