.nh
.TH "X86-PREFETCHWT1" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
PREFETCHWT1 - PREFETCH VECTOR DATA INTO CACHES WITH INTENT TO WRITE AND T1 HINT
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
0F 0D /2 PREFETCHWT1 m8	M	V/V	PREFETCHWT1	T{
Move data from m8 closer to the processor using T1 hint with intent to write.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
M	ModRM:r/m (r)	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Fetches the line of data from memory that contains the byte specified
with the source operand to a location in the cache hierarchy specified
by an intent to write hint (so that data is brought into ‘Exclusive’
state via a request for ownership) and a locality hint:

.RS
.IP \(bu 2
T1 (temporal data with respect to first level cache)—prefetch data
into the second level cache.

.RE

.PP
The source operand is a byte memory location. (The locality hints are
encoded into the machine level instruction using bits 3 through 5 of the
ModR/M byte. Use of any ModR/M value other than the specified ones will
lead to unpredictable behavior.)

.PP
If the line selected is already present in the cache hierarchy at a
level closer to the processor, no data movement occurs. Prefetches from
uncacheable or WC memory are ignored.

.PP
The PREFETCHh instruction is merely a hint and does not affect program
behavior. If executed, this instruction moves data closer to the
processor in anticipation of future use.

.PP
The implementation of prefetch locality hints is
implementation\-dependent, and can be overloaded or ignored by a
processor implementation. The amount of data prefetched is also
processor implementation\-dependent. It will, however, be a minimum of 32
bytes.

.PP
It should be noted that processors are free to speculatively fetch and
cache data from system memory regions that are assigned a memory\-type
that permits speculative reads (that is, the WB, WC, and WT memory
types). A PREFETCHh instruction is considered a hint to this speculative
behavior. Because this speculative fetching can occur at any time and is
not tied to instruction execution, a PREFETCHh instruction is not
ordered with respect to the fence instructions (MFENCE, SFENCE, and
LFENCE) or locked memory references. A PREFETCHh instruction is also
unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other
PREFETCHh instructions, or any other general instruction. It is ordered
with respect to serializing instructions such as CPUID, WRMSR, OUT, and
MOV CR.

.PP
This instruction’s operation is the same in non\-64\-bit modes and 64\-bit
mode.

.SH OPERATION
.PP
.RS

.nf
PREFETCH(mem, Level, State) Prefetches a byte memory location pointed by ‘mem’ into the cache level specified by ‘Level’; a request
for exclusive/ownership is done if ‘State’ is 1. Note that the memory location ignore cache line splits. This operation is considered a
hint for the processor and may be skipped depending on implementation.
Prefetch (m8, Level = 1, EXCLUSIVE=1);

.fi
.RE

.SH FLAGS AFFECTED
.PP
All flags are affected

.SH C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
void \_mm\_prefetch( char const *, int hint= \_MM\_HINT\_ET1);

.fi
.RE

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
