.nh
.TH "X86-VBROADCAST" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VBROADCAST - LOAD WITH BROADCAST FLOATING-POINT DATA
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
VEX.128.66.0F38.W0 18 /r VBROADCASTSS xmm1, m32
T}
	A	V/V	AVX	T{
Broadcast single\-precision floating\-point element in mem to four locations in xmm1.
T}
T{
VEX.256.66.0F38.W0 18 /r VBROADCASTSS ymm1, m32
T}
	A	V/V	AVX	T{
Broadcast single\-precision floating\-point element in mem to eight locations in ymm1.
T}
T{
VEX.256.66.0F38.W0 19 /r VBROADCASTSD ymm1, m64
T}
	A	V/V	AVX	T{
Broadcast double\-precision floating\-point element in mem to four locations in ymm1.
T}
T{
VEX.256.66.0F38.W0 1A /r VBROADCASTF128 ymm1, m128
T}
	A	V/V	AVX	T{
Broadcast 128 bits of floating\-point data in mem to low and high 128\-bits in ymm1.
T}
T{
VEX.128.66.0F38.W0 18/r VBROADCASTSS xmm1, xmm2
T}
	A	V/V	AVX2	T{
Broadcast the low single\-precision floating\-point element in the source operand to four locations in xmm1.
T}
T{
VEX.256.66.0F38.W0 18 /r VBROADCASTSS ymm1, xmm2
T}
	A	V/V	AVX2	T{
Broadcast low single\-precision floating\-point element in the source operand to eight locations in ymm1.
T}
T{
VEX.256.66.0F38.W0 19 /r VBROADCASTSD ymm1, xmm2
T}
	A	V/V	AVX2	T{
Broadcast low double\-precision floating\-point element in the source operand to four locations in ymm1.
T}
T{
EVEX.256.66.0F38.W1 19 /r VBROADCASTSD ymm1 {k1}{z}, xmm2/m64
T}
	B	V/V	AVX512VL AVX512F	T{
Broadcast low double\-precision floating\-point element in xmm2/m64 to four locations in ymm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W1 19 /r VBROADCASTSD zmm1 {k1}{z}, xmm2/m64
T}
	B	V/V	AVX512F	T{
Broadcast low double\-precision floating\-point element in xmm2/m64 to eight locations in zmm1 using writemask k1.
T}
T{
EVEX.256.66.0F38.W0 19 /r VBROADCASTF32X2 ymm1 {k1}{z}, xmm2/m64
T}
	C	V/V	AVX512VL AVX512DQ	T{
Broadcast two single\-precision floating\-point elements in xmm2/m64 to locations in ymm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W0 19 /r VBROADCASTF32X2 zmm1 {k1}{z}, xmm2/m64
T}
	C	V/V	AVX512DQ	T{
Broadcast two single\-precision floating\-point elements in xmm2/m64 to locations in zmm1 using writemask k1.
T}
T{
EVEX.128.66.0F38.W0 18 /r VBROADCASTSS xmm1 {k1}{z}, xmm2/m32
T}
	B	V/V	AVX512VL AVX512F	T{
Broadcast low single\-precision floating\-point element in xmm2/m32 to all locations in xmm1 using writemask k1.
T}
T{
EVEX.256.66.0F38.W0 18 /r VBROADCASTSS ymm1 {k1}{z}, xmm2/m32
T}
	B	V/V	AVX512VL AVX512F	T{
Broadcast low single\-precision floating\-point element in xmm2/m32 to all locations in ymm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W0 18 /r VBROADCASTSS zmm1 {k1}{z}, xmm2/m32
T}
	B	V/V	AVX512F	T{
Broadcast low single\-precision floating\-point element in xmm2/m32 to all locations in zmm1 using writemask k1.
T}
T{
EVEX.256.66.0F38.W0 1A /r VBROADCASTF32X4 ymm1 {k1}{z}, m128
T}
	D	V/V	AVX512VL AVX512F	T{
Broadcast 128 bits of 4 single\-precision floating\-point data in mem to locations in ymm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W0 1A /r VBROADCASTF32X4 zmm1 {k1}{z}, m128
T}
	D	V/V	AVX512F	T{
Broadcast 128 bits of 4 single\-precision floating\-point data in mem to locations in zmm1 using writemask k1.
T}
T{
EVEX.256.66.0F38.W1 1A /r VBROADCASTF64X2 ymm1 {k1}{z}, m128
T}
	C	V/V	AVX512VL AVX512DQ	T{
Broadcast 128 bits of 2 double\-precision floating\-point data in mem to locations in ymm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W1 1A /r VBROADCASTF64X2 zmm1 {k1}{z}, m128
T}
	C	V/V	AVX512DQ	T{
Broadcast 128 bits of 2 double\-precision floating\-point data in mem to locations in zmm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W0 1B /r VBROADCASTF32X8 zmm1 {k1}{z}, m256
T}
	E	V/V	AVX512DQ	T{
Broadcast 256 bits of 8 single\-precision floating\-point data in mem to locations in zmm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W1 1B /r VBROADCASTF64X4 zmm1 {k1}{z}, m256
T}
	D	V/V	AVX512F	T{
Broadcast 256 bits of 4 double\-precision floating\-point data in mem to locations in zmm1 using writemask k1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	NA	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
B	Tuple1 Scalar	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
C	Tuple2	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
D	Tuple4	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
E	Tuple8	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
.TE

.SS Description
.PP
VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating\-point values as
one tuple from the source operand (second operand) in memory and
broadcast to all elements of the destination operand (first operand).

.PP
VEX256\-encoded versions: The destination operand is a YMM register. The
source operand is either a 32\-bit, 64\-bit, or 128\-bit memory location.
Register source encodings are reserved and will #UD. Bits (MAXVL\-1:256)
of the destination register are zeroed.

.PP
EVEX\-encoded versions: The destination operand is a ZMM/YMM/XMM register
and updated according to the writemask k1. The source operand is either
a 32\-bit, 64\-bit memory location or the low doubleword/quadword element
of an XMM register.

.PP
VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4
load floating\-point values as tuples from the source operand (the second
operand) in memory or register and broadcast to all elements of the
destination operand (the first operand). The destination operand is a
YMM/ZMM register updated according to the writemask k1. The source
operand is either a register or 64\-bit/128\-bit/256\-bit memory location.

.PP
VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as
256\-bit and 512\-bit wide versions and up. VBROADCASTSS is supported in
128\-bit, 256\-bit and 512\-bit wide versions. F32x8 and F64x4 are only
supported as 512\-bit wide versions.

.PP
VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32\-bit granularity.
VBROADCASTF64X2 and VBROADCASTF64X4 have 64\-bit granularity.

.PP
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise
instructions will #UD.

.PP
If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt
to execute the instruction encoded with VEX.L= 0 will cause an #UD
exception.

.PP
X0m32DESTX0X0X0X0X0X0X0X0

.PP
Figure 5\-1. VBROADCASTSS Operation (VEX.256 encoded version)

.PP
X0m32DEST0000X0X0X0X0

.PP
Figure 5\-2. VBROADCASTSS Operation (VEX.128\-bit version)

.PP
X0DESTX0X0X0X0

.PP
Figure 5\-3. VBROADCASTSD Operation (VEX.256\-bit version)

.PP
m128X0DESTX0X0

.PP
Figure 5\-4. VBROADCASTF128 Operation (VEX.256\-bit version)

.PP
m256X0DESTX0X0

.PP
Figure 5\-5. VBROADCASTF64X4 Operation (512\-bit version with writemask
all 1s)

.SS Operation
.SS VBROADCASTSS (128 bit version VEX and legacy)
.PP
.RS

.nf
temp ← SRC[31:0]
DEST[31:0] ← temp
DEST[63:32] ← temp
DEST[95:64] ← temp
DEST[127:96] ← temp
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SS VBROADCASTSS (VEX.256 encoded version)
.PP
.RS

.nf
temp ← SRC[31:0]
DEST[31:0] ← temp
DEST[63:32] ← temp
DEST[95:64] ← temp
DEST[127:96] ← temp
DEST[159:128] ← temp
DEST[191:160] ← temp
DEST[223:192] ← temp
DEST[255:224] ← temp
DEST[MAXVL\-1:256] ← 0

.fi
.RE

.SS VBROADCASTSS (EVEX encoded versions)
.PP
.RS

.nf
(KL, VL) (4, 128), (8, 256),= (16, 512)
FOR j←0 TO KL\-1
    i←j * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i]←SRC[31:0]
        ELSE
            IF *merging\-masking*
                        ; merging\-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE
                        ; zeroing\-masking
                    DEST[i+31:i] ← 0
            FI
    FI;
ENDFOR
DEST[MAXVL\-1:VL] ← 0

.fi
.RE

.SS VBROADCASTSD (VEX.256 encoded version)
.PP
.RS

.nf
temp ← SRC[63:0]
DEST[63:0] ← temp
DEST[127:64] ← temp
DEST[191:128] ← temp
DEST[255:192] ← temp
DEST[MAXVL\-1:256] ← 0

.fi
.RE

.SS VBROADCASTSD (EVEX encoded versions)
.PP
.RS

.nf
(KL, VL) = (4, 256), (8, 512)
FOR j←0 TO KL\-1
    i←j * 64
    IF k1[j] OR *no writemask*
        THEN DEST[i+63:i]←SRC[63:0]
        ELSE
            IF *merging\-masking*
                        ; merging\-masking
                THEN *DEST[i+63:i] remains unchanged*
                ELSE
                        ; zeroing\-masking
                    DEST[i+63:i] ← 0
            FI
    FI;
ENDFOR
DEST[MAXVL\-1:VL] ← 0

.fi
.RE

.SS VBROADCASTF32x2 (EVEX encoded versions)
.PP
.RS

.nf
(KL, VL) = (8, 256), (16, 512)
FOR j←0 TO KL\-1
    i← j * 32
    n← (j mod 2) * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i]←SRC[n+31:n]
        ELSE
            IF *merging\-masking*
                        ; merging\-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE
                        ; zeroing\-masking
                    DEST[i+31:i] ← 0
            FI
    FI;
ENDFOR
DEST[MAXVL\-1:VL] ← 0

.fi
.RE

.SS VBROADCASTF128 (VEX.256 encoded version)
.PP
.RS

.nf
temp ← SRC[127:0]
DEST[127:0] ← temp
DEST[255:128] ← temp
DEST[MAXVL\-1:256] ← 0

.fi
.RE

.SS VBROADCASTF32X4 (EVEX encoded versions)
.PP
.RS

.nf
(KL, VL) = (8, 256), (16, 512)
FOR j←0 TO KL\-1
    i← j* 32
    n← (j modulo 4) * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i]←SRC[n+31:n]
        ELSE
            IF *merging\-masking*
                        ; merging\-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE
                        ; zeroing\-masking
                    DEST[i+31:i] ← 0
            FI
    FI;
ENDFOR
DEST[MAXVL\-1:VL] ← 0

.fi
.RE

.SS VBROADCASTF64X2 (EVEX encoded versions)
.PP
.RS

.nf
(KL, VL) = (4, 256), (8, 512)
FOR j←0 TO KL\-1
    i←j * 64
    n←(j modulo 2) * 64
    IF k1[j] OR *no writemask*
        THEN DEST[i+63:i]←SRC[n+63:n]
        ELSE
            IF *merging\-masking*
                THEN *DEST[i+63:i] remains unchanged*
                ELSE ; zeroing\-masking
                    DEST[i+63:i] = 0
            FI
    FI;
ENDFOR;

.fi
.RE

.SS VBROADCASTF32X8 (EVEX.U1.512 encoded version)
.PP
.RS

.nf
FOR j←0 TO 15
    i←j * 32
    n←(j modulo 8) * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i]←SRC[n+31:n]
        ELSE
            IF *merging\-masking*
                        ; merging\-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE
                        ; zeroing\-masking
                    DEST[i+31:i] ← 0
            FI
    FI;
ENDFOR
DEST[MAXVL\-1:VL] ← 0

.fi
.RE

.SS VBROADCASTF64X4 (EVEX.512 encoded version)
.PP
.RS

.nf
FOR j←0 TO 7
    i←j * 64
    n← (j modulo 4) * 64
    IF k1[j] OR *no writemask*
        THEN DEST[i+63:i]←SRC[n+63:n]
        ELSE
            IF *merging\-masking*
                THEN *DEST[i+63:i] remains unchanged*
                ELSE ; zeroing\-masking
                    DEST[i+63:i] ← 0
            FI
    FI;
ENDFOR
DEST[MAXVL\-1:VL] ← 0

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
VBROADCASTF32x2 \_\_m512 \_mm512\_broadcast\_f32x2( \_\_m128 a);

VBROADCASTF32x2 \_\_m512 \_mm512\_mask\_broadcast\_f32x2(\_\_m512 s, \_\_mmask16 k, \_\_m128 a);

VBROADCASTF32x2 \_\_m512 \_mm512\_maskz\_broadcast\_f32x2( \_\_mmask16 k, \_\_m128 a);

VBROADCASTF32x2 \_\_m256 \_mm256\_broadcast\_f32x2( \_\_m128 a);

VBROADCASTF32x2 \_\_m256 \_mm256\_mask\_broadcast\_f32x2(\_\_m256 s, \_\_mmask8 k, \_\_m128 a);

VBROADCASTF32x2 \_\_m256 \_mm256\_maskz\_broadcast\_f32x2( \_\_mmask8 k, \_\_m128 a);

VBROADCASTF32x4 \_\_m512 \_mm512\_broadcast\_f32x4( \_\_m128 a);

VBROADCASTF32x4 \_\_m512 \_mm512\_mask\_broadcast\_f32x4(\_\_m512 s, \_\_mmask16 k, \_\_m128 a);

VBROADCASTF32x4 \_\_m512 \_mm512\_maskz\_broadcast\_f32x4( \_\_mmask16 k, \_\_m128 a);

VBROADCASTF32x4 \_\_m256 \_mm256\_broadcast\_f32x4( \_\_m128 a);

VBROADCASTF32x4 \_\_m256 \_mm256\_mask\_broadcast\_f32x4(\_\_m256 s, \_\_mmask8 k, \_\_m128 a);

VBROADCASTF32x4 \_\_m256 \_mm256\_maskz\_broadcast\_f32x4( \_\_mmask8 k, \_\_m128 a);

VBROADCASTF32x8 \_\_m512 \_mm512\_broadcast\_f32x8( \_\_m256 a);

VBROADCASTF32x8 \_\_m512 \_mm512\_mask\_broadcast\_f32x8(\_\_m512 s, \_\_mmask16 k, \_\_m256 a);

VBROADCASTF32x8 \_\_m512 \_mm512\_maskz\_broadcast\_f32x8( \_\_mmask16 k, \_\_m256 a);

VBROADCASTF64x2 \_\_m512d \_mm512\_broadcast\_f64x2( \_\_m128d a);

VBROADCASTF64x2 \_\_m512d \_mm512\_mask\_broadcast\_f64x2(\_\_m512d s, \_\_mmask8 k, \_\_m128d a);

VBROADCASTF64x2 \_\_m512d \_mm512\_maskz\_broadcast\_f64x2( \_\_mmask8 k, \_\_m128d a);

VBROADCASTF64x2 \_\_m256d \_mm256\_broadcast\_f64x2( \_\_m128d a);

VBROADCASTF64x2 \_\_m256d \_mm256\_mask\_broadcast\_f64x2(\_\_m256d s, \_\_mmask8 k, \_\_m128d a);

VBROADCASTF64x2 \_\_m256d \_mm256\_maskz\_broadcast\_f64x2( \_\_mmask8 k, \_\_m128d a);

VBROADCASTF64x4 \_\_m512d \_mm512\_broadcast\_f64x4( \_\_m256d a);

VBROADCASTF64x4 \_\_m512d \_mm512\_mask\_broadcast\_f64x4(\_\_m512d s, \_\_mmask8 k, \_\_m256d a);

VBROADCASTF64x4 \_\_m512d \_mm512\_maskz\_broadcast\_f64x4( \_\_mmask8 k, \_\_m256d a);

VBROADCASTSD \_\_m512d \_mm512\_broadcastsd\_pd( \_\_m128d a);

VBROADCASTSD \_\_m512d \_mm512\_mask\_broadcastsd\_pd(\_\_m512d s, \_\_mmask8 k, \_\_m128d a);

VBROADCASTSD \_\_m512d \_mm512\_maskz\_broadcastsd\_pd(\_\_mmask8 k, \_\_m128d a);

VBROADCASTSD \_\_m256d \_mm256\_broadcastsd\_pd(\_\_m128d a);

VBROADCASTSD \_\_m256d \_mm256\_mask\_broadcastsd\_pd(\_\_m256d s, \_\_mmask8 k, \_\_m128d a);

VBROADCASTSD \_\_m256d \_mm256\_maskz\_broadcastsd\_pd( \_\_mmask8 k, \_\_m128d a);

VBROADCASTSD \_\_m256d \_mm256\_broadcast\_sd(double *a);

VBROADCASTSS \_\_m512 \_mm512\_broadcastss\_ps( \_\_m128 a);

VBROADCASTSS \_\_m512 \_mm512\_mask\_broadcastss\_ps(\_\_m512 s, \_\_mmask16 k, \_\_m128 a);

VBROADCASTSS \_\_m512 \_mm512\_maskz\_broadcastss\_ps( \_\_mmask16 k, \_\_m128 a);

VBROADCASTSS \_\_m256 \_mm256\_broadcastss\_ps(\_\_m128 a);

VBROADCASTSS \_\_m256 \_mm256\_mask\_broadcastss\_ps(\_\_m256 s, \_\_mmask8 k, \_\_m128 a);

VBROADCASTSS \_\_m256 \_mm256\_maskz\_broadcastss\_ps( \_\_mmask8 k, \_\_m128 a);

VBROADCASTSS \_\_m128 \_mm\_broadcastss\_ps(\_\_m128 a);

VBROADCASTSS \_\_m128 \_mm\_mask\_broadcastss\_ps(\_\_m128 s, \_\_mmask8 k, \_\_m128 a);

VBROADCASTSS \_\_m128 \_mm\_maskz\_broadcastss\_ps( \_\_mmask8 k, \_\_m128 a);

VBROADCASTSS \_\_m128 \_mm\_broadcast\_ss(float *a);

VBROADCASTSS \_\_m256 \_mm256\_broadcast\_ss(float *a);

VBROADCASTF128 \_\_m256 \_mm256\_broadcast\_ps(\_\_m128 * a);

VBROADCASTF128 \_\_m256d \_mm256\_broadcast\_pd(\_\_m128d * a);

.fi
.RE

.SS Exceptions
.PP
VEX\-encoded instructions, see Exceptions Type 6;

.PP
EVEX\-encoded instructions, see Exceptions Type E6.

.TS
allbox;
l l 
l l .
#UD	T{
If VEX.L = 0 for VBROADCASTSD or VBROADCASTF128.
T}
	T{
If EVEX.L’L = 0 for VBROADCASTSD/VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2.
T}
	If EVEX.L’L 
\&lt;
T{
 10b for VBROADCASTF32X8/VBROADCASTF64X4.
T}
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
