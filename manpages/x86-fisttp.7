.nh
.TH "X86-FISTTP" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
FISTTP - STORE INTEGER WITH TRUNCATION
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fC64\-Bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
DF /1	FISTTP m16int	Valid	Valid	T{
Store ST(0) in m16int with truncation.
T}
DB /1	FISTTP m32int	Valid	Valid	T{
Store ST(0) in m32int with truncation.
T}
DD /1	FISTTP m64int	Valid	Valid	T{
Store ST(0) in m64int with truncation.
T}
.TE

.SH DESCRIPTION
.PP
FISTTP converts the value in ST into a signed integer using truncation
(chop) as rounding mode, transfers the result to the destination, and
pop ST. FISTTP accepts word, short integer, and long integer
destinations.

.PP
The following table shows the results obtained when storing various
classes of numbers in integer format.

.TS
allbox;
l l 
l l .
\fB\fCST(0)\fR	\fB\fCDEST\fR
T{
− ∞ or Value Too Large for DEST Format
T}
	
*
F≤ −1	−I
−1\&lt;F\&lt;+1	0
FŠ+1	+I
+T{
 ∞ or Value Too Large for DEST Format
T}
	
*
NaN	
*
.TE

.PP
Table 3\-28. FISTTP Results

.PP
.RS

.PP
F Meansfinitefloating\-pointvalue.

.PP
Ι Means integer.

.PP
∗ Indicates floating\-point invalid\-operation (#IA) exception.

.RE

.PP
This instruction’s operation is the same in non\-64\-bit modes and 64\-bit
mode.

.SH OPERATION
.PP
.RS

.nf
DEST ← ST;
pop ST;

.fi
.RE

.SH FLAGS AFFECTED
.PP
C1 is cleared; C0, C2, C3 undefined.

.SH NUMERIC EXCEPTIONS
.PP
Invalid, Stack Invalid (stack underflow), Precision.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If the destination is in a nonwritable segment.
T}
	T{
For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.
T}
#SS(0)	T{
For an illegal address in the SS segment.
T}
#PF(fault\-code)	For a page fault.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#NM	If CR0.EM
[
bit 2
]
 = 1.
	If CR0.TS
[
bit 3
]
 = 1.
#UD	If CPUID.01H:ECX.SSE3
[
bit 0
]
 = 0.
	If the LOCK prefix is used.
.TE

.SH REAL ADDRESS MODE EXCEPTIONS
.PP
GP(0) If any part of the operand would lie outside of the effective
address space from 0 to 0FFFFH.

.TS
allbox;
l l 
l l .
#NM	If CR0.EM
[
bit 2
]
 = 1.
	If CR0.TS
[
bit 3
]
 = 1.
#UD	If CPUID.01H:ECX.SSE3
[
bit 0
]
 = 0.
	If the LOCK prefix is used.
.TE

.SH VIRTUAL 8086 MODE EXCEPTIONS
.PP
GP(0) If any part of the operand would lie outside of the effective
address space from 0 to 0FFFFH.

.TS
allbox;
l l 
l l .
#NM	If CR0.EM
[
bit 2
]
 = 1.
	If CR0.TS
[
bit 3
]
 = 1.
#UD	If CPUID.01H:ECX.SSE3
[
bit 0
]
 = 0.
	If the LOCK prefix is used.
#PF(fault\-code)	For a page fault.
#AC(0)	T{
For unaligned memory reference if the current privilege is 3.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#SS(0)	T{
If a memory address referencing the SS segment is in a non\-canonical form.
T}
#GP(0)	T{
If the memory address is in a non\-canonical form.
T}
#NM	CR0.EM
[
bit 2
]
 or CR0.TS
[
bit 3
]
 = 1.
#MF	T{
If there is a pending x87 FPU exception.
T}
#PF(fault\-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
	If the LOCK prefix is used.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
