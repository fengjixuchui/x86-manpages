.nh
.TH "X86-RDSEED" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
RDSEED - READ RANDOM SEED
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
NFx 0F C7 /7 RDSEED r16	M	V/V	RDSEED	T{
Read a 16\-bit NIST SP800\-90B \& C compliant random value and store in the destination register.
T}
NFx 0F C7 /7 RDSEED r32	M	V/V	RDSEED	T{
Read a 32\-bit NIST SP800\-90B \& C compliant random value and store in the destination register.
T}
T{
NFx REX.W + 0F C7 /7 RDSEED r64
T}
	M	V/I	RDSEED	T{
Read a 64\-bit NIST SP800\-90B \& C compliant random value and store in the destination register.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
M	ModRM:r/m (w)	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Loads a hardware generated random value and store it in the destination
register. The random value is generated from an Enhanced NRBG (Non
Deterministic Random Bit Generator) that is compliant to NIST SP800\-90B
and NIST SP800\-90C in the XOR construction mode. The size of the random
value is determined by the destination register size and operating mode.
The Carry Flag indicates whether a random value is available at the time
the instruction is executed. CF=1 indicates that the data in the
destination is valid. Otherwise CF=0 and the data in the destination
operand will be returned as zeros for the specified width. All other
flags are forced to 0 in either situation. Software must check the state
of CF=1 for determining if a valid random seed value has been returned,
otherwise it is expected to loop and retry execution of RDSEED (see
Section 1.2).

.PP
The RDSEED instruction is available at all privilege levels. The RDSEED
instruction executes normally either inside or outside a transaction
region.

.PP
In 64\-bit mode, the instruction's default operation size is 32 bits.
Using a REX prefix in the form of REX.B permits access to additional
registers (R8\-R15). Using a REX prefix in the form of REX.W promotes
operation to 64 bit operands. See the summary chart at the beginning of
this section for encoding data and limits.

.SH OPERATION
.PP
.RS

.nf
IF HW\_NRND\_GEN.ready = 1
    THEN
        CASE of
            osize is 64: DEST[63:0] ← HW\_NRND\_GEN.data;
            osize is 32: DEST[31:0] ← HW\_NRND\_GEN.data;
            osize is 16: DEST[15:0] ← HW\_NRND\_GEN.data;
        ESAC;
        CF ← 1;
    ELSE
        CASE of
            osize is 64: DEST[63:0] ← 0;
            osize is 32: DEST[31:0] ← 0;
            osize is 16: DEST[15:0] ← 0;
        ESAC;
        CF ← 0;
FI;
OF, SF, ZF, AF, PF ← 0;

.fi
.RE

.SH FLAGS AFFECTED
.PP
The CF flag is set according to the result (see the "Operation" section
above). The OF, SF, ZF, AF, and PF flags are set to 0.

.SH C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
RDSEED int \_rdseed16\_step( unsigned short * );

RDSEED int \_rdseed32\_step( unsigned int * );

RDSEED int \_rdseed64\_step( unsigned \_\_int64 *);

.fi
.RE

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
	T{
If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED
T}
[
bit 18
]
 = 0.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
	T{
If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED
T}
[
bit 18
]
 = 0.
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
	T{
If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED
T}
[
bit 18
]
 = 0.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
	T{
If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED
T}
[
bit 18
]
 = 0.
.TE

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
	T{
If CPUID.(EAX=07H, ECX=0H):EBX.RDSEED
T}
[
bit 18
]
 = 0.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
