.nh
.TH "X86-SARX-SHLX-SHRX" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
SARX-SHLX-SHRX - SHIFT WITHOUT AFFECTING FLAGS
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 \-bit Mode\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
VEX.LZ.F3.0F38.W0 F7 /r SARX r32a, r/m32, r32b
T}
	RMV	V/V	BMI2	Shift r32b.
T{
VEX.LZ.66.0F38.W0 F7 /r SHLX r32a, r/m32, r32b
T}
	RMV	V/V	BMI2	Shift r32b.
T{
VEX.LZ.F2.0F38.W0 F7 /r SHRX r32a, r/m32, r32b
T}
	RMV	V/V	BMI2	Shift r32b.
T{
VEX.LZ.F3.0F38.W1 F7 /r SARX r64a, r/m64, r64b
T}
	RMV	V/N.E.	BMI2	Shift r64b.
T{
VEX.LZ.66.0F38.W1 F7 /r SHLX r64a, r/m64, r64b
T}
	RMV	V/N.E.	BMI2	Shift r64b.
T{
VEX.LZ.F2.0F38.W1 F7 /r SHRX r64a, r/m64, r64b
T}
	RMV	V/N.E.	BMI2	Shift r64b.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RMV	ModRM:reg (w)	ModRM:r/m (r)	VEX.vvvv (r)	NA
.TE

.SH DESCRIPTION
.PP
Shifts the bits of the first source operand (the second operand) to the
left or right by a COUNT value specified in the second source operand
(the third operand). The result is written to the destination operand
(the first operand).

.PP
The shift arithmetic right (SARX) and shift logical right (SHRX)
instructions shift the bits of the destination operand to the right
(toward less significant bit locations), SARX keeps and propagates the
most significant bit (sign bit) while shifting.

.PP
The logical shift left (SHLX) shifts the bits of the destination operand
to the left (toward more significant bit locations).

.PP
This instruction is not supported in real mode and virtual\-8086 mode.
The operand size is always 32 bits if not in 64\-bit mode. In 64\-bit mode
operand size 64 requires VEX.W1. VEX.W1 is ignored in non\-64\-bit modes.
An attempt to execute this instruction with VEX.L not equal to 0 will
cause #UD.

.PP
If the value specified in the first source operand exceeds OperandSize
\-1, the COUNT value is masked.

.PP
SARX,SHRX, and SHLX instructions do not update flags.

.SH OPERATION
.PP
.RS

.nf
TEMP ← SRC1;
IF VEX.W1 and CS.L = 1
THEN
    countMASK ←3FH;
ELSE
    countMASK ←1FH;
FI
COUNT ← (SRC2 AND countMASK)
DEST[OperandSize \-1] = TEMP[OperandSize \-1];
DO WHILE (COUNT ≠ 0)
    IF instruction is SHLX
        THEN
            DEST[] ← DEST *2;
        ELSE IF instruction is SHRX
            THEN
                DEST[] ← DEST /2; //unsigned divide
        ELSE // SARX
                DEST[] ← DEST /2; // signed divide, round toward negative infinity
    COUNT ← COUNT \- 1;
OD

.fi
.RE

.SH FLAGS AFFECTED
.PP
None.

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
Auto\-generated from high\-level language.

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 13.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
