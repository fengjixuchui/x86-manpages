.nh
.TH "X86-SHA256RNDS2" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
SHA256RNDS2 - PERFORM TWO ROUNDS OF SHA256 OPERATION
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
NP 0F 38 CB /r SHA256RNDS2 xmm1, xmm2/m128, 
T}
\&lt;XMM0\&gt;	RM0	V/V	SHA	T{
Perform 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from xmm1, an initial SHA256 state (A,B,E,F) from xmm2/m128, and a pre\-computed sum of the next 2 round message dwords and the corresponding round constants from the implicit operand XMM0, storing the updated SHA256 state (A,B,E,F) result in xmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l 
l l l l .
Op/En	Operand 1	Operand 2	Operand 3
RMI	ModRM:reg (r, w)	ModRM:r/m (r)	Implicit XMM0 (r)
.TE

.SS Description
.PP
The SHA256RNDS2 instruction performs 2 rounds of SHA256 operation using
an initial SHA256 state (C,D,G,H) from the first operand, an initial
SHA256 state (A,B,E,F) from the second operand, and a pre\-computed sum
of the next 2 round message dwords and the corresponding round constants
from the implicit operand xmm0. Note that only the two lower dwords of
XMM0 are used by the instruction.

.PP
The updated SHA256 state (A,B,E,F) is written to the first operand, and
the second operand can be used as the updated state (C,D,G,H) in later
rounds.

.SS Operation
.SS SHA256RNDS2
.PP
.RS

.nf
A\_0 ← SRC2[127:96];
B\_0 ← SRC2[95:64];
C\_0 ← SRC1[127:96];
D\_0 ← SRC1[95:64];
E\_0 ← SRC2[63:32];
F\_0 ← SRC2[31:0];
G\_0 ← SRC1[63:32];
H\_0 ← SRC1[31:0];
WK0 ← XMM0[31: 0];
WK1 ← XMM0[63: 32];
FOR i = 0 to 1
    A\_(i +1) ← Ch (E\_i, F\_i, G\_i) +Σ1( E\_i) +WKi+ H\_i + Maj(A\_i , B\_i, C\_i) +Σ0( A\_i);
    B\_(i +1)←A\_i;
    C\_(i +1)←B\_i ;
    D\_(i +1)←C\_i;
    E\_(i +1)←Ch (E\_i, F\_i, G\_i) +Σ1( E\_i) +WKi+ H\_i + D\_i;
    F\_(i +1)←E\_i ;
    G\_(i +1)←F\_i;
    H\_(i +1)←G\_i;
ENDFOR
DEST[127:96] ← A\_2;
DEST[95:64] ← B\_2;
DEST[63:32] ← E\_2;
DEST[31:0] ← F\_2;

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
SHA256RNDS2: \_\_m128i \_mm\_sha256rnds2\_epu32(\_\_m128i, \_\_m128i, \_\_m128i);

.fi
.RE

.SS Flags Affected
.PP
None

.SS SIMD Floating\-Point Exceptions
.PP
None

.SS Other Exceptions
.PP
See Exceptions Type 4.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
