.nh
.TH "X86-EREPORT" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
EREPORT - CREATE A CRYPTOGRAPHIC REPORT OF THE ENCLAVE
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
EAX = 00H ENCLU[EREPORT]	IR	V/V	SGX1	T{
This leaf function creates a cryptographic report of the enclave.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	EAX	RBX	RCX	RDX
IR	EREPORT (In)	Address of TARGETINFO (In)	Address of REPORTDATA (In)	T{
Address where the REPORT is written to in an OUTPUTDATA (In)
T}
.TE

.SS Description
.PP
This leaf function creates a cryptographic REPORT that describes the
contents of the enclave. This instruction leaf can only be executed when
inside the enclave. The cryptographic report can be used by other
enclaves to determine that the enclave is running on the same platform.

.PP
RBX contains the effective address of the MRENCLAVE value of the enclave
that will authenticate the REPORT output, using the REPORT key delivered
by EGETKEY command for that enclave. RCX contains the effective address
of a 64\-byte REPORTDATA structure, which allows the caller of the
instruction to associate data with the enclave from which the
instruction is called. RDX contains the address where the REPORT will be
output by the instruction.

.SH EREPORT MEMORY PARAMETER SEMANTICS
.TS
allbox;
l l l 
l l l .
TARGETINFO	REPORTDATA	OUTPUTDATA
Read access by Enclave	Read access by Enclave	Read/Write access by Enclave
.TE

.PP
This instruction leaf perform the following:

.PP
1\&. Validate the 3 operands (RBX, RCX, RDX) are inside the enclave.

.PP
2\&. Compute a report key for the target enclave, as indicated by the
value located in RBX(TARGETINFO).

.PP
3\&. Assemble the enclave SECS data to complete the REPORT structure
(including the data provided using the RCX (REPORTDATA) operand).

.PP
4\&. Computes a cryptographic hash over REPORT structure.

.PP
5\&. Add the computed hash to the REPORT structure.

.PP
6\&. Output the completed REPORT structure to the address in RDX
(OUTPUTDATA).

.PP
The instruction fails if the operands are not properly aligned.

.PP
CR\_REPORT\_KEYID, used to provide key wearout protection, is populated
with a statistically unique value on boot of the platform by a trusted
entity within the SGX TCB.

.PP
The instruction faults if any of the following:

.SH EREPORT FAULTING CONDITIONS
.TS
allbox;
l l 
l l .
T{
An effective address not properly aligned.
T}
	T{
An memory address does not resolve in an EPC page.
T}
T{
If accessing an invalid EPC page.
T}
	If the EPC page is blocked.
May page fault.	.TE

.SS Concurrency Restrictions
.PP
Leaf

.PP
Parameter

.PP
Base Concurrency Restrictions

.PP
Access

.PP
On Conflict

.PP
SGX\_CONFLICT VM Exit Qualification

.PP
EREPORT

.PP
TARGETINFO [DS:RBX]

.PP
Concurrent

.PP
REPORTDATA [DS:RCX]

.PP
Concurrent

.PP
OUTPUTDATA [DS:RDX]

.PP
Concurrent

.PP
Table 40\-70\&. Base Concurrency
Restrictions of EREPORT

.PP
Leaf

.PP
Parameter

.PP
Additional Concurrency Restrictions

.PP
vs. EACCEPT, EACCEPTCOPY, EMODPE, EMODPR, EMODT

.PP
vs. EADD, EEXTEND, EINIT

.PP
vs. ETRACK, ETRACKC

.PP
Access

.PP
On Conflict

.PP
Access

.PP
On Conflict

.PP
Access

.PP
On Conflict

.PP
EREPORT

.PP
TARGETINFO [DS:RBX]

.PP
Concurrent

.PP
Concurrent

.PP
Concurrent

.PP
REPORTDATA [DS:RCX]

.PP
Concurrent

.PP
Concurrent

.PP
Concurrent

.PP
OUTPUTDATA [DS:RDX]

.PP
Concurrent

.PP
Concurrent

.PP
Concurrent

.PP
Table 40\-71\&. Additional Concurrency
Restrictions of EREPORT

.SS Operation
.SH TEMP VARIABLES IN EREPORT OPERATIONAL FLOW
.TS
allbox;
l l l l 
l l l l .
\fB\fCName\fR	\fB\fCType\fR	\fB\fCSize (bits)\fR	\fB\fCDescription\fR
TMP\_ATTRIBUTES		32	T{
Physical address of SECS of the enclave to which source operand belongs.
T}
TMP\_CURRENTSECS			T{
Address of the SECS for the currently executing enclave.
T}
TMP\_KEYDEPENDENCIES			Temp space for key derivation.
TMP\_REPORTKEY		128	T{
REPORTKEY generated by the instruction.
T}
TMP\_REPORT		3712	.TE

.PP
TMP\_MODE64←((IA32\_EFER.LMA = 1) \&\& (CS.L = 1));

.PP
(* Address verification for TARGETINFO (RBX) *)

.PP
IF ( (DS:RBX is not 512Byte Aligned) or (DS:RBX is not within
CR\_ELRANGE) )

.PP
THEN #GP(0); FI;

.PP
IF (DS:RBX does not resolve within an EPC)

.PP
THEN #PF(DS:RBX); FI;

.PP
IF (EPCM(DS:RBX).VALID = 0)

.PP
THEN #PF(DS:RBX); FI;

.PP
IF (EPCM(DS:RBX).BLOCKED = 1)

.PP
THEN #PF(DS:RBX); FI;

.PP
(* Check page parameters for correctness *)

.PP
IF ( (EPCM(DS:RBX).PT ≠ PT\_REG) or (EPCM(DS:RBX).ENCLAVESECS ≠
CR\_ACTIVE\_SECS) or (EPCM(DS:RBX).PENDING = 1) or

.PP
(EPCM(DS:RBX).MODIFIED = 1) or (EPCM(DS:RBX).ENCLAVEADDRESS ≠ (DS:RBX \&
\~0FFFH) ) or (EPCM(DS:RBX).R = 0) )

.PP
THEN #PF(DS:RBX);

.PP
FI;

.PP
(* Address verification for REPORTDATA (RCX) *)

.PP
IF ( (DS:RCX is not 128Byte Aligned) or (DS:RCX is not within
CR\_ELRANGE) )

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX does not resolve within an EPC)

.PP
THEN #PF(DS:RCX); FI;

.PP
IF (EPCM(DS:RCX).VALID = 0)

.PP
THEN #PF(DS:RCX); FI;

.PP
IF (EPCM(DS:RCX).BLOCKED = 1)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* Check page parameters for correctness *)

.PP
IF ( (EPCM(DS:RCX).PT ≠ PT\_REG) or (EPCM(DS:RCX).ENCLAVESECS ≠
CR\_ACTIVE\_SECS) or (EPCM(DS:RCX).PENDING = 1) or

.PP
(EPCM(DS:RCX).MODIFIED = 1) or (EPCM(DS:RCX).ENCLAVEADDRESS ≠ (DS:RCX \&
\~0FFFH) ) or (EPCM(DS:RCX).R = 0) )

.PP
THEN #PF(DS:RCX);

.PP
FI;

.PP
(* Address verification for OUTPUTDATA (RDX) *)

.PP
IF ( (DS:RDX is not 512Byte Aligned) or (DS:RDX is not within
CR\_ELRANGE) )

.PP
THEN #GP(0); FI;

.PP
IF (DS:RDX does not resolve within an EPC)

.PP
THEN #PF(DS:RDX); FI;

.PP
IF (EPCM(DS:RDX).VALID = 0)

.PP
THEN #PF(DS:RDX); FI;

.PP
IF (EPCM(DS:RDX).BLOCKED = 1)

.PP
THEN #PF(DS:RDX); FI;

.PP
(* Check page parameters for correctness *)

.PP
IF ( (EPCM(DS:RDX).PT ≠ PT\_REG) or (EPCM(DS:RDX).ENCLAVESECS ≠
CR\_ACTIVE\_SECS) or (EPCM(DS:RCX).PENDING = 1) or

.PP
(EPCM(DS:RCX).MODIFIED = 1) or (EPCM(DS:RDX).ENCLAVEADDRESS ≠ (DS:RDX \&
\~0FFFH) ) or (EPCM(DS:RDX).W = 0) )

.PP
THEN #PF(DS:RDX);

.PP
FI;

.PP
(* REPORT MAC needs to be computed over data which cannot be modified
*)

.PP
TMP\_REPORT.CPUSVN ← CR\_CPUSVN;

.PP
TMP\_REPORT.ISVFAMILYID ← TMP\_CURRENTSECS.ISVFAMILYID;

.PP
TMP\_REPORT.ISVEXTPRODID ← TMP\_CURRENTSECS.ISVEXTPRODID;

.PP
TMP\_REPORT.ISVPRODID ← TMP\_CURRENTSECS.ISVPRODID;

.PP
TMP\_REPORT.ISVSVN ← TMP\_CURRENTSECS.ISVSVN;

.PP
TMP\_REPORT.ATTRIBUTES ← TMP\_CURRENTSECS.ATTRIBUTES;

.PP
TMP\_REPORT.REPORTDATA ← DS:RCX[511:0];

.PP
TMP\_REPORT.MRENCLAVE ← TMP\_CURRENTSECS.MRENCLAVE;

.PP
TMP\_REPORT.MRSIGNER ← TMP\_CURRENTSECS.MRSIGNER;

.PP
TMP\_REPORT.MRRESERVED ← 0;

.PP
TMP\_REPORT.KEYID[255:0] ← CR\_REPORT\_KEYID;

.PP
TMP\_REPORT.MISCSELECT ← TMP\_CURRENTSECS.MISCSELECT;

.PP
TMP\_REPORT.CONFIGID ← TMP\_CURRENTSECS.CONFIGID;

.PP
TMP\_REPORT.CONFIGSVN ← TMP\_CURRENTSECS.CONFIGSVN;

.PP
(* Derive the report key *)

.PP
TMP\_KEYDEPENDENCIES.KEYNAME ← REPORT\_KEY;

.PP
TMP\_KEYDEPENDENCIES.ISVFAMILYID ← 0;

.PP
TMP\_KEYDEPENDENCIES.ISVEXTPRODID ← 0;

.PP
TMP\_KEYDEPENDENCIES.ISVPRODID ← 0;

.PP
TMP\_KEYDEPENDENCIES.ISVSVN ← 0;

.PP
TMP\_KEYDEPENDENCIES.SGXOWNEREPOCH ← CR\_SGXOWNEREPOCH;

.PP
TMP\_KEYDEPENDENCIES.ATTRIBUTES ← DS:RBX.ATTRIBUTES;

.PP
TMP\_KEYDEPENDENCIES.ATTRIBUTESMASK ← 0;

.PP
TMP\_KEYDEPENDENCIES.MRENCLAVE ← DS:RBX.MEASUREMENT;

.PP
TMP\_KEYDEPENDENCIES.MRSIGNER ← 0;

.PP
TMP\_KEYDEPENDENCIES.KEYID ← TMP\_REPORT.KEYID;

.PP
TMP\_KEYDEPENDENCIES.SEAL\_KEY\_FUSES ← CR\_SEAL\_FUSES;

.PP
TMP\_KEYDEPENDENCIES.CPUSVN ← CR\_CPUSVN;

.PP
TMP\_KEYDEPENDENCIES.PADDING ← TMP\_CURRENTSECS.PADDING;

.PP
TMP\_KEYDEPENDENCIES.MISCSELECT ← DS:RBX.MISCSELECT;

.PP
TMP\_KEYDEPENDENCIES.MISCMASK ← 0;

.PP
TMP\_KEYDEPENDENCIES.KEYPOLICY ← 0;

.PP
TMP\_KEYDEPENDENCIES.CONFIGID ← DS:RBX.CONFIGID;

.PP
TMP\_KEYDEPENDENCIES.CONFIGSVN ← DS:RBX.CONFIGSVN;

.PP
(* Calculate the derived key*)

.PP
TMP\_REPORTKEY ← derive\_key(TMP\_KEYDEPENDENCIES);

.PP
(* call cryptographic CMAC function, CMAC data are not including
MAC\&KEYID *)

.PP
TMP\_REPORT.MAC←cmac(TMP\_REPORTKEY, TMP\_REPORT[3071:0] );

.PP
DS:RDX[3455: 0]←TMP\_REPORT;

.SS Flags Affected
.PP
None

.SS Protected Mode Exceptions
.PP
#GP(0)

.PP
If executed outside an enclave.

.PP
If the address in RCS is outside the DS segment limit.

.PP
If a memory operand is not properly aligned.

.PP
If a memory operand is not in the current enclave.

.PP
#PF(error

.PP
code) If a page fault occurs in accessing memory operands.

.SS 64\-Bit Mode Exceptions
.PP
#GP(0)

.PP
If executed outside an enclave.

.PP
If RCX is non\-canonical form.

.PP
If a memory operand is not properly aligned.

.PP
If a memory operand is not in the current enclave.

.PP
#PF(error

.PP
code) If a page fault occurs in accessing memory operands.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
