.nh
.TH "X86-FCMOVCC" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
FCMOVCC - FLOATING-POINT CONDITIONAL MOVE
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode*\fR	\fB\fCInstruction\fR	\fB\fC64\-Bit Mode\fR	\fB\fCCompat/Leg Mode*\fR	\fB\fCDescription\fR
DA C0+i	FCMOVB ST(0), ST(i)	Valid	Valid	Move if below (CF=1).
DA C8+i	FCMOVE ST(0), ST(i)	Valid	Valid	Move if equal (ZF=1).
DA D0+i	FCMOVBE ST(0), ST(i)	Valid	Valid	T{
Move if below or equal (CF=1 or ZF=1).
T}
DA D8+i	FCMOVU ST(0), ST(i)	Valid	Valid	Move if unordered (PF=1).
DB C0+i	FCMOVNB ST(0), ST(i)	Valid	Valid	Move if not below (CF=0).
DB C8+i	FCMOVNE ST(0), ST(i)	Valid	Valid	Move if not equal (ZF=0).
DB D0+i	FCMOVNBE ST(0), ST(i)	Valid	Valid	T{
Move if not below or equal (CF=0 and ZF=0).
T}
DB D8+i	FCMOVNU ST(0), ST(i)	Valid	Valid	Move if not unordered (PF=0).
.TE

.PP
.RS

.PP
* SeeIA\-32ArchitectureCompatibilitysectionbelow.

.RE

.SH DESCRIPTION
.PP
Tests the status flags in the EFLAGS register and moves the source
operand (second operand) to the destination operand (first operand) if
the given test condition is true. The condition for each mnemonic os
given in the Description column above and in Chapter 8 in the Intel® 64
and IA\-32 Architectures Software Developer’s Manual, Volume 1. The
source operand is always in the ST(i) register and the destination
operand is always ST(0).

.PP
The FCMOVcc instructions are useful for optimizing small IF
constructions. They also help eliminate branching overhead for IF
operations and the possibility of branch mispredictions by the
processor.

.PP
A processor may not support the FCMOVcc instructions are supported.

.PP
This instruction’s operation is the same in non\-64\-bit modes and 64\-bit
mode.

.SH IA\-32 ARCHITECTURE COMPATIBILITY
.PP
The FCMOVcc instructions were introduced to the IA\-32 Architecture in
the P6 family processors and are not available in earlier IA\-32
processors.

.SH OPERATION
.PP
.RS

.nf
IF condition TRUE
    THEN ST(0) ← ST(i);
FI;

.fi
.RE

.SH FPU FLAGS AFFECTED
.TS
allbox;
l l 
l l .
C1	T{
Set to 0 if stack underflow occurred.
T}
C0, C2, C3	Undefined.
.TE

.SH FLOATING\-POINT EXCEPTIONS
.TS
allbox;
l l 
l l .
#IS	Stack underflow occurred.
.TE

.SH INTEGER FLAGS AFFECTED
.PP
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#NM	CR0.EM
[
bit 2
]
 or CR0.TS
[
bit 3
]
 = 1.
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
