.nh
.TH "X86-AESENCLAST" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
AESENCLAST - PERFORM LAST ROUND OF AN AES ENCRYPTION FLOW
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32\-bit Mode\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
66 0F 38 DD /r AESENCLAST xmm1, xmm2/m128
T}
	RM	V/V	AES	T{
Perform the last round of an AES encryption flow, operating on a 128\-bit data (state) from xmm1 with a 128\-bit round key from xmm2/m128.
T}
T{
VEX.128.66.0F38.WIG DD /r VAESENCLAST xmm1, xmm2, xmm3/m128
T}
	RVM	V/V	Both AES and AVX flags	T{
Perform the last round of an AES encryption flow, operating on a 128\-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand2	Operand3	Operand4
RM	ModRM:reg (r, w)	ModRM:r/m (r)	NA	NA
RVM	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	NA
.TE

.SH DESCRIPTION
.PP
This instruction performs the last round of an AES encryption flow using
a round key from the second source operand, operating on 128\-bit data
(state) from the first source operand, and store the result in the
destination operand.

.PP
128\-bit Legacy SSE version: The first source operand and the destination
operand are the same and must be an XMM register. The second source
operand can be an XMM register or a 128\-bit memory location. Bits
(MAXVL\-1:128) of the corresponding YMM destination register remain
unchanged.

.PP
VEX.128 encoded version: The first source operand and the destination
operand are XMM registers. The second source operand can be an XMM
register or a 128\-bit memory location. Bits (MAXVL\-1:128) of the
destination YMM register are zeroed.

.SH OPERATION
.SS AESENCLAST
.PP
.RS

.nf
STATE ← SRC1;
RoundKey ← SRC2;
STATE ← ShiftRows( STATE );
STATE ← SubBytes( STATE );
DEST[127:0] ← STATE XOR RoundKey;
DEST[MAXVL\-1:128] (Unmodified)

.fi
.RE

.SS VAESENCLAST
.PP
.RS

.nf
STATE ← SRC1;
RoundKey ← SRC2;
STATE←ShiftRows( STATE );
STATE←SubBytes( STATE );
DEST[127:0]←STATE XOR RoundKey;
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
(V)AESENCLAST: \_\_m128i \_mm\_aesenclast (\_\_m128i, \_\_m128i)

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
