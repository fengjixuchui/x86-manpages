.nh
.TH "X86-COMISS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
COMISS - COMPARE SCALAR ORDERED SINGLE-PRECISION FLOATING-POINT VALUES AND SET EFLAGS
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
NP 0F 2F /r COMISS xmm1, xmm2/m32
T}
	A	V/V	SSE	T{
Compare low single\-precision floating\-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
T}
T{
VEX.LIG.0F.WIG 2F /r VCOMISS xmm1, xmm2/m32
T}
	A	V/V	AVX	T{
Compare low single\-precision floating\-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
T}
T{
EVEX.LIG.0F.W0 2F /r VCOMISS xmm1, xmm2/m32{sae}
T}
	B	V/V	AVX512F	T{
Compare low single\-precision floating\-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	NA	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
B	Tuple1 Scalar	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
.TE

.SH DESCRIPTION
.PP
Compares the single\-precision floating\-point values in the low quadwords
of operand 1 (first operand) and operand 2 (second operand), and sets
the ZF, PF, and CF flags in the EFLAGS register according to the result
(unordered, greater than, less than, or equal). The OF, SF and AF flags
in the EFLAGS register are set to 0. The unordered result is returned if
either source operand is a NaN (QNaN or SNaN).

.PP
Operand 1 is an XMM register; operand 2 can be an XMM register or a 32
bit memory location.

.PP
The COMISS instruction differs from the UCOMISS instruction in that it
signals a SIMD floating\-point invalid operation exception (#I) when a
source operand is either a QNaN or SNaN. The UCOMISS instruction signals
an invalid numeric exception only if a source operand is an SNaN.

.PP
The EFLAGS register is not updated if an unmasked SIMD floating\-point
exception is generated.

.PP
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise
instructions will #UD.

.PP
Software should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS
with VEX.L=1 may encounter unpredictable behavior across different
processor generations.

.SH OPERATION
.SS COMISS (all versions)
.PP
.RS

.nf
RESULT← OrderedCompare(DEST[31:0] <> SRC[31:0]) {
(* Set EFLAGS *) CASE (RESULT) OF
    UNORDERED: ZF,PF,CF←111;
    GREATER\_THAN: ZF,PF,CF←000;
    LESS\_THAN: ZF,PF,CF←001;
    EQUAL: ZF,PF,CF←100;
ESAC;
OF, AF, SF←0; }

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
VCOMISS int \_mm\_comi\_round\_ss(\_\_m128 a, \_\_m128 b, int imm, int sae);

VCOMISS int \_mm\_comieq\_ss (\_\_m128 a, \_\_m128 b)

VCOMISS int \_mm\_comilt\_ss (\_\_m128 a, \_\_m128 b)

VCOMISS int \_mm\_comile\_ss (\_\_m128 a, \_\_m128 b)

VCOMISS int \_mm\_comigt\_ss (\_\_m128 a, \_\_m128 b)

VCOMISS int \_mm\_comige\_ss (\_\_m128 a, \_\_m128 b)

VCOMISS int \_mm\_comineq\_ss (\_\_m128 a, \_\_m128 b)

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
Invalid (if SNaN or QNaN operands), Denormal.

.SH OTHER EXCEPTIONS
.PP
VEX\-encoded instructions, see Exceptions Type 3;

.PP
EVEX\-encoded instructions, see Exceptions Type E3NF.

.TS
allbox;
l l 
l l .
#UD	T{
If VEX.vvvv != 1111B or EVEX.vvvv != 1111B.
T}
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
