.nh
.TH "X86-BEXTR" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
BEXTR - BIT FIELD EXTRACT
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 \-bit Mode\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
VEX.LZ.0F38.W0 F7 /r BEXTR r32a, r/m32, r32b
T}
	RMV	V/V	BMI1	T{
Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a.
T}
T{
VEX.LZ.0F38.W1 F7 /r BEXTR r64a, r/m64, r64b
T}
	RMV	V/N.E.	BMI1	T{
Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RMV	ModRM:reg (w)	ModRM:r/m (r)	VEX.vvvv (r)	NA
.TE

.SH DESCRIPTION
.PP
Extracts contiguous bits from the first source operand (the second
operand) using an index value and length value specified in the second
source operand (the third operand). Bit 7:0 of the second source operand
specifies the starting bit position of bit extraction. A START value
exceeding the operand size will not extract any bits from the second
source operand. Bit 15:8 of the second source operand specifies the
maximum number of bits (LENGTH) beginning at the START position to
extract. Only bit positions up to (OperandSize \-1) of the first source
operand are extracted. The extracted bits are written to the destination
register, starting from the least significant bit. All higher order bits
in the destination operand (starting at bit position LENGTH) are zeroed.
The destination register is cleared if no bits are extracted.

.PP
This instruction is not supported in real mode and virtual\-8086 mode.
The operand size is always 32 bits if not in 64\-bit mode. In 64\-bit mode
operand size 64 requires VEX.W1. VEX.W1 is ignored in non\-64\-bit modes.
An attempt to execute this instruction with VEX.L not equal to 0 will
cause #UD.

.SH OPERATION
.PP
.RS

.nf
START ← SRC2[7:0];
LEN ← SRC2[15:8];
TEMP ← ZERO\_EXTEND\_TO\_512 (SRC1 );
DEST ← ZERO\_EXTEND(TEMP[START+LEN \-1: START]);
ZF ← (DEST = 0);

.fi
.RE

.SH FLAGS AFFECTED
.PP
ZF is updated based on the result. AF, SF, and PF are undefined. All
other flags are cleared.

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
BEXTR: unsigned \_\_int32 \_bextr\_u32(unsigned \_\_int32 src, unsigned \_\_int32 start. unsigned \_\_int32 len);

BEXTR: unsigned \_\_int64 \_bextr\_u64(unsigned \_\_int64 src, unsigned \_\_int32 start. unsigned \_\_int32 len);

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 13; additionally

.TS
allbox;
l l 
l l .
#UD	If VEX.W = 1.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
