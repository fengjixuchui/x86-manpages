.nh
.TH "X86-VPBLENDMB-VPBLENDMW" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VPBLENDMB-VPBLENDMW - BLEND BYTE-WORD VECTORS USING AN OPMASK CONTROL
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
EVEX.128.66.0F38.W0 66 /r VPBLENDMB xmm1 {k1}{z}, xmm2, xmm3/m128
T}
	A	V/V	AVX512VL AVX512BW	T{
Blend byte integer vector xmm2 and byte vector xmm3/m128 and store the result in xmm1, under control mask.
T}
T{
EVEX.256.66.0F38.W0 66 /r VPBLENDMB ymm1 {k1}{z}, ymm2, ymm3/m256
T}
	A	V/V	AVX512VL AVX512BW	T{
Blend byte integer vector ymm2 and byte vector ymm3/m256 and store the result in ymm1, under control mask.
T}
T{
EVEX.512.66.0F38.W0 66 /r VPBLENDMB zmm1 {k1}{z}, zmm2, zmm3/m512
T}
	A	V/V	AVX512BW	T{
Blend byte integer vector zmm2 and byte vector zmm3/m512 and store the result in zmm1, under control mask.
T}
T{
EVEX.128.66.0F38.W1 66 /r VPBLENDMW xmm1 {k1}{z}, xmm2, xmm3/m128
T}
	A	V/V	AVX512VL AVX512BW	T{
Blend word integer vector xmm2 and word vector xmm3/m128 and store the result in xmm1, under control mask.
T}
T{
EVEX.256.66.0F38.W1 66 /r VPBLENDMW ymm1 {k1}{z}, ymm2, ymm3/m256
T}
	A	V/V	AVX512VL AVX512BW	T{
Blend word integer vector ymm2 and word vector ymm3/m256 and store the result in ymm1, under control mask.
T}
T{
EVEX.512.66.0F38.W1 66 /r VPBLENDMW zmm1 {k1}{z}, zmm2, zmm3/m512
T}
	A	V/V	AVX512BW	T{
Blend word integer vector zmm2 and word vector zmm3/m512 and store the result in zmm1, under control mask.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	Full Mem	ModRM:reg (w)	EVEX.vvvv	ModRM:r/m (r)	NA
.TE

.SS Description
.PP
Performs an element\-by\-element blending of byte/word elements between
the first source operand byte vector register and the second source
operand byte vector from memory or register, using the instruction mask
as selector. The result is written into the destination byte vector
register.

.PP
The destination and first source operands are ZMM/YMM/XMM registers. The
second source operand can be a ZMM/YMM/XMM register, a 512/256/128\-bit
memory location or a 512/256/128\-bit memory location.

.PP
The mask is not used as a writemask for this instruction. Instead, the
mask is used as an element selector: every element of the destination is
conditionally selected between first source or second source using the
value of the related mask bit (0 for first source, 1 for second source).

.SS Operation
.SS VPBLENDMB (EVEX encoded versions)
.PP
.RS

.nf
(KL, VL) = (16, 128), (32, 256), (64, 512)
FOR j←0 TO KL\-1
    i←j * 8
    IF k1[j] OR *no writemask*
        THEN DEST[i+7:i]←SRC2[i+7:i]
        ELSE
            IF *merging\-masking*
                        ; merging\-masking
                THEN DEST[i+7:i]←SRC1[i+7:i]
                ELSE
                        ; zeroing\-masking
                    DEST[i+7:i] ← 0
            FI;
    FI;
ENDFOR
DEST[MAXVL\-1:VL] ← 0;

.fi
.RE

.SS VPBLENDMW (EVEX encoded versions)
.PP
.RS

.nf
(KL, VL) = (8, 128), (16, 256), (32, 512)
FOR j←0 TO KL\-1
    i←j * 16
    IF k1[j] OR *no writemask*
        THEN DEST[i+15:i]←SRC2[i+15:i]
        ELSE
            IF *merging\-masking*
                THEN DEST[i+15:i]←SRC1[i+15:i]
                ELSE ; zeroing\-masking
                    DEST[i+15:i] ← 0
            FI;
    FI;
ENDFOR
DEST[MAXVL\-1:VL] ← 0

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
VPBLENDMB \_\_m512i \_mm512\_mask\_blend\_epi8(\_\_mmask64 m, \_\_m512i a, \_\_m512i b);

VPBLENDMB \_\_m256i \_mm256\_mask\_blend\_epi8(\_\_mmask32 m, \_\_m256i a, \_\_m256i b);

VPBLENDMB \_\_m128i \_mm\_mask\_blend\_epi8(\_\_mmask16 m, \_\_m128i a, \_\_m128i b);

VPBLENDMW \_\_m512i \_mm512\_mask\_blend\_epi16(\_\_mmask32 m, \_\_m512i a, \_\_m512i b);

VPBLENDMW \_\_m256i \_mm256\_mask\_blend\_epi16(\_\_mmask16 m, \_\_m256i a, \_\_m256i b);

VPBLENDMW \_\_m128i \_mm\_mask\_blend\_epi16(\_\_mmask8 m, \_\_m128i a, \_\_m128i b);

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
None

.SS Other Exceptions
.PP
See Exceptions Type E4.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
