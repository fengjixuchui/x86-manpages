.nh
.TH "X86-RSQRTSS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
RSQRTSS - COMPUTE RECIPROCAL OF SQUARE ROOT OF SCALAR SINGLE-PRECISION FLOATING-POINT VALUE
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode*/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
F3 0F 52 /xmm2/m32	RM	V/V	SSE	T{
Computes the approximate reciprocal of the square root of the low single\-precision floating\-point value in xmm1.
T}
T{
VEX.LIG.F3.0F.WIG 52 /r VRSQRTSS xmm1, xmm2, xmm3/m32
T}
	RVM	V/V	AVX	T{
Computes the approximate reciprocal of the square root of the low single precision floating\-point value in xmm1
T}
[
127:32
]
\&.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RM	ModRM:reg (w)	ModRM:r/m (r)	NA	NA
RVM	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	NA
.TE

.SH DESCRIPTION
.PP
Computes an approximate reciprocal of the square root of the low
single\-precision floating\-point value in the source operand (second
operand) stores the single\-precision floating\-point result in the
destination operand. The source operand can be an XMM register or a
32\-bit memory location. The destination operand is an XMM register. The
three high\-order doublewords of the destination operand remain
unchanged. See Figure 10\-6 in the
Intel® 64 and IA\-32 Architectures Software Developer’s Manual, Volume 1,
for an illustration of a scalar single\-precision floating\-point
operation.

.PP
The relative error for this approximation is:

.PP
|Relative Error| ≤ 1.5 ∗ 2−12

.PP
The RSQRTSS instruction is not affected by the rounding control bits in
the MXCSR register. When a source value is a 0.0, an ∞ of the sign of
the source value is returned. A denormal source value is treated as a
0.0 (of the same sign). When a source value is a negative value (other
than −0.0), a floating\-point indefinite is returned. When a source value
is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN
is returned.

.PP
In 64\-bit mode, using a REX prefix in the form of REX.R permits this
instruction to access additional registers (XMM8\-XMM15).

.PP
128\-bit Legacy SSE version: The first source operand and the destination
operand are the same. Bits (MAXVL\-1:32) of the corresponding YMM
destination register remain unchanged.

.PP
VEX.128 encoded version: Bits (MAXVL\-1:128) of the destination YMM
register are zeroed.

.SH OPERATION
.SS RSQRTSS (128\-bit Legacy SSE version)
.PP
.RS

.nf
DEST[31:0] ← APPROXIMATE(1/SQRT(SRC2[31:0]))
DEST[MAXVL\-1:32] (Unmodified)

.fi
.RE

.SS VRSQRTSS (VEX.128 encoded version)
.PP
.RS

.nf
DEST[31:0] ← APPROXIMATE(1/SQRT(SRC2[31:0]))
DEST[127:32] ← SRC1[127:32]
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
RSQRTSS: \_\_m128 \_mm\_rsqrt\_ss(\_\_m128 a)

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None.

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 5.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
