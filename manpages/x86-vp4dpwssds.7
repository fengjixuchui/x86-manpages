.nh
.TH "X86-VP4DPWSSDS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VP4DPWSSDS - DOT PRODUCT OF SIGNED WORDS WITH DWORD ACCUMULATION AND SATURATION (4-ITERATIONS)
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
EVEX.512.F2.0F38.W0 53 /r VP4DPWSSDS zmm1{k1}{z}, zmm2+3, m128
T}
	A	V/V	AVX512\_4VNNIW	T{
Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate the resulting dword results with signed saturation in zmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l 
l .
T{
Op/En Tuple Operand 1 Operand 2 Operand 3 Operand 4
T}
A Tuple1
\_
T{
4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA
T}
.TE

.SS Description
.PP
This instruction computes 4 sequential register source\-block
dot\-products of two signed word operands with doubleword accumulation
and signed saturation. The memory operand is sequentially selected in
each of the four steps.

.PP
In the above box, the notation of “+3” is used to denote that the
instruction accesses 4 source registers based on that operand; sources
are consecutive, start in a multiple of 4 boundary, and contain the
encoded register operand.

.PP
This instruction supports memory fault suppression. The entire memory
operand is loaded if any bit of the lowest 16\-bits of the mask is set to
1 or if a “no masking” encoding is used.

.PP
The tuple type Tuple1\_4X implies that four 32\-bit elements (16 bytes)
are referenced by the memory operation portion of this instruction.

.SS Operation
.PP
.RS

.nf
src\_reg\_id is the 5 bit index of the vector register specified in the instruction as the src1 register.
VP4DPWSSDS dest, src1, src2
(KL,VL) = (16,512)
N←4
ORIGDEST ← DEST
src\_base ← src\_reg\_id \& \~ (N\-1) // for src1 operand
FOR i ← 0 to KL\-1:
    IF k1[i] or *no writemask*:
        FOR m ← 0 to N\-1:
            t ← SRC2.dword[m]
            p1dword ← reg[src\_base+m].word[2*i] * t.word[0]
            p2dword ← reg[src\_base+m].word[2*i+1] * t.word[1]
            DEST.dword[i] ← SIGNED\_DWORD\_SATURATE(DEST.dword[i] + p1dword + p2dword)
    ELSE IF *zeroing*:
        DEST.dword[i] ← 0
    ELSE
        DEST.dword[i] ← ORIGDEST.dword[i]
DEST[MAX\_VL\-1:VL] ← 0

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
VP4DPWSSDS \_\_m512i \_mm512\_4dpwssds\_epi32(\_\_m512i, \_\_m512ix4, \_\_m128i *);

VP4DPWSSDS \_\_m512i \_mm512\_mask\_4dpwssds\_epi32(\_\_m512i, \_\_mmask16, \_\_m512ix4, \_\_m128i *);

VP4DPWSSDS \_\_m512i \_mm512\_maskz\_4dpwssds\_epi32(\_\_mmask16, \_\_m512i, \_\_m512ix4, \_\_m128i *);

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
None.

.SS Other Exceptions
.PP
See Type E4; additionally

.TS
allbox;
l l 
l l .
#UD	T{
If the EVEX broadcast bit is set to 1.
T}
#UD	If the MODRM.mod = 0b11.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
