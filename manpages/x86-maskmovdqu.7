.nh
.TH "X86-MASKMOVDQU" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
MASKMOVDQU - STORE SELECTED BYTES OF DOUBLE QUADWORD
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32\-bit Mode\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
66 0F F7 /xmm2	RM	V/V	SSE2	T{
Selectively write bytes from xmm2. The default memory location is specified by DS:DI/EDI/RDI.
T}
T{
VEX.128.66.0F.WIG F7 /r VMASKMOVDQU xmm1, xmm2
T}
	RM	V/V	AVX	T{
Selectively write bytes from xmm2. The default memory location is specified by DS:DI/EDI/RDI.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING1
.PP
.RS

.PP
1.ModRM.MOD = 011B required

.RE

.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RM	ModRM:reg (r)	ModRM:r/m (r)	NA	NA
.TE

.SH DESCRIPTION
.PP
Stores selected bytes from the source operand (first operand) into an
128\-bit memory location. The mask operand (second operand) selects which
bytes from the source operand are written to memory. The source and mask
operands are XMM registers. The memory location specified by the
effective address in the DI/EDI/RDI register (the default segment
register is DS, but this may be overridden with a segment\-override
prefix). The memory location does not need to be aligned on a natural
boundary. (The size of the store address depends on the address\-size
attribute.)

.PP
The most significant bit in each byte of the mask operand determines
whether the corresponding byte in the source operand is written to the
corresponding byte location in memory: 0 indicates no write and 1
indicates write.

.PP
The MASKMOVDQU instruction generates a non\-temporal hint to the
processor to minimize cache pollution. The non\-temporal hint is
implemented by using a write combining (WC) memory type protocol (see
“Caching of Temporal vs. Non\-Temporal Data” in Chapter 10, of the Intel®
64 and IA\-32 Architectures Software Developer’s Manual, Volume 1).
Because the WC protocol uses a weakly\-ordered memory consistency model,
a fencing operation implemented with the SFENCE or MFENCE instruction
should be used in conjunction with MASKMOVDQU instructions if multiple
processors might use different memory types to read/write the
destination memory locations.

.PP
Behavior with a mask of all 0s is as follows:

.RS
.IP \(bu 2
No data will be written to memory.
.IP \(bu 2
Signaling of breakpoints (code or data) is not guaranteed; different
processor implementations may signal or not signal these
breakpoints.
.IP \(bu 2
Exceptions associated with addressing memory and page faults may
still be signaled (implementation dependent).
.IP \(bu 2
If the destination memory region is mapped as UC or WP, enforcement
of associated semantics for these memory types is not guaranteed
(that is, is reserved) and is implementation\-specific.

.RE

.PP
The MASKMOVDQU instruction can be used to improve performance of
algorithms that need to merge data on a byte\-by\-byte basis. MASKMOVDQU
should not cause a read for ownership; doing so generates unnecessary
bandwidth since data is to be written directly using the byte\-mask
without allocating old data prior to the store.

.PP
In 64\-bit mode, use of the REX.R prefix permits this instruction to
access additional registers (XMM8\-XMM15).

.PP
Note: In VEX\-encoded versions, VEX.vvvv is reserved and must be 1111b
otherwise instructions will #UD.

.PP
If VMASKMOVDQU is encoded with VEX.L= 1, an attempt to execute the
instruction encoded with VEX.L= 1 will cause an #UD exception.

.SH OPERATION
.PP
.RS

.nf
IF (MASK[7] = 1)
    THEN DEST[DI/EDI] ← SRC[7:0] ELSE (* Memory location unchanged *); FI;
IF (MASK[15] = 1)
    THEN DEST[DI/EDI +1] ← SRC[15:8] ELSE (* Memory location unchanged *); FI;
    (* Repeat operation for 3rd through 14th bytes in source operand *)
IF (MASK[127] = 1)
    THEN DEST[DI/EDI +15] ← SRC[127:120] ELSE (* Memory location unchanged *); FI;

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
void \_mm\_maskmoveu\_si128(\_\_m128i d, \_\_m128i n, char * p)

.fi
.RE

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4; additionally

.TS
allbox;
l l 
l l .
#UD	If VEX.L= 1
	If VEX.vvvv ≠ 1111B.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
