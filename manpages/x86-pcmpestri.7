.nh
.TH "X86-PCMPESTRI" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
PCMPESTRI - PACKED COMPARE EXPLICIT LENGTH STRINGS, RETURN INDEX
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
66 0F 3A 61 xmm1, xmm2/m128, imm8
T}
	RMI	V/V	SSE4\_2	T{
Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
T}
T{
VEX.128.66.0F3A 61 /r ib VPCMPESTRI xmm1, xmm2/m128, imm8
T}
	RMI	V/V	AVX	T{
Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RMI	ModRM:reg (r)	ModRM:r/m (r)	imm8	NA
.TE

.SH DESCRIPTION
.PP
The instruction compares and processes data from two string fragments
based on the encoded value in the Imm8 Control Byte (see Section 4.1,
“Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI /
PCMPISTRM”), and generates an index stored to the count register (ECX).

.PP
Each string fragment is represented by two values. The first value is an
xmm (or possibly m128 for the second operand) which contains the data
elements of the string (byte or word data). The second value is stored
in an input length register. The input length register is EAX/RAX (for
xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of
bytes/words which are valid for the respective xmm/m128 data.

.PP
The length of each input is interpreted as being the absolute\-value of
the value in the length register. The absolute\-value computation
saturates to 16 (for bytes) and 8 (for words), based on the value of
imm8[bit3] when the value in the length register is greater than 16
(8) or less than \-16 (\-8).

.PP
The comparison and aggregation operations are performed according to the
encoded value of Imm8 bit fields (see Section 4.1). The index of the
first (or last, according to imm8[6]) set bit of IntRes2 (see Section
4.1.4) is returned in ECX. If no bits are set in IntRes2, ECX is set to
16 (8).

.PP
Note that the Arithmetic Flags are written in a non\-standard manner in
order to supply the most relevant information:

.PP
CFlag – Reset if IntRes2 is equal to zero, set otherwise

.PP
ZFlag – Set if absolute\-value of EDX is \&lt; 16 (8), reset otherwise

.PP
SFlag – Set if absolute\-value of EAX is \&lt; 16 (8), reset otherwise

.PP
OFlag – IntRes2[0]

.PP
AFlag – Reset

.PP
PFlag – Reset

.SH EFFECTIVE OPERAND SIZE
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fCOperating mode/size\fR	\fB\fCOperand 1\fR	\fB\fCOperand 2\fR	\fB\fCLength 1\fR	\fB\fCLength 2\fR	\fB\fCResult\fR
16 bit	xmm	xmm/m128	EAX	EDX	ECX
32 bit	xmm	xmm/m128	EAX	EDX	ECX
64 bit	xmm	xmm/m128	EAX	EDX	ECX
64 bit + REX.W	xmm	xmm/m128	RAX	RDX	ECX
.TE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT FOR RETURNING INDEX
.PP
int \_mm\_cmpestri (\_\_m128i a, int la, \_\_m128i b, int lb, const int
mode);

.SH INTEL C/C++ COMPILER INTRINSICS FOR READING EFLAG RESULTS
.PP
int \_mm\_cmpestra (\_\_m128i a, int la, \_\_m128i b, int lb, const int
mode);

.PP
int \_mm\_cmpestrc (\_\_m128i a, int la, \_\_m128i b, int lb, const int
mode);

.PP
int \_mm\_cmpestro (\_\_m128i a, int la, \_\_m128i b, int lb, const int
mode);

.PP
int \_mm\_cmpestrs (\_\_m128i a, int la, \_\_m128i b, int lb, const int
mode);

.PP
int \_mm\_cmpestrz (\_\_m128i a, int la, \_\_m128i b, int lb, const int
mode);

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None.

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4; additionally, this instruction does not cause
#GP if the memory operand is not aligned to 16 Byte boundary, and

.TS
allbox;
l l 
l l .
#UD	If VEX.L = 1.
	If VEX.vvvv ≠ 1111B.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
