.nh
.TH "X86-LTR" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
LTR - LOAD TASK REGISTER
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fCOp/En\fR	\fB\fC64\-Bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
0F 00 /3	LTR r/m16	M	Valid	Valid	Load r/m16 into task register.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
M	ModRM:r/m (r)	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Loads the source operand into the segment selector field of the task
register. The source operand (a general\-purpose register or a memory
location) contains a segment selector that points to a task state
segment (TSS). After the segment selector is loaded in the task
register, the processor uses the segment selector to locate the segment
descriptor for the TSS in the global descriptor table (GDT). It then
loads the segment limit and base address for the TSS from the segment
descriptor into the task register. The task pointed to by the task
register is marked busy, but a switch to the task does not occur.

.PP
The LTR instruction is provided for use in operating\-system software; it
should not be used in application programs. It can only be executed in
protected mode when the CPL is 0. It is commonly used in initialization
code to establish the first task to be executed.

.PP
The operand\-size attribute has no effect on this instruction.

.PP
In 64\-bit mode, the operand size is still fixed at 16 bits. The
instruction references a 16\-byte descriptor to load the 64\-bit base.

.SH OPERATION
.PP
.RS

.nf
IF SRC is a NULL selector
    THEN #GP(0);
IF SRC(Offset) > descriptor table limit OR IF SRC(type) ≠ global
    THEN #GP(segment selector); FI;
Read segment descriptor;
IF segment descriptor is not for an available TSS
    THEN #GP(segment selector); FI;
IF segment descriptor is not present
    THEN #NP(segment selector); FI;
TSSsegmentDescriptor(busy) ← 1;
(* Locked read\-modify\-write operation on the entire descriptor when setting busy flag *)
TaskRegister(SegmentSelector) ← SRC;
TaskRegister(SegmentDescriptor) ← TSSSegmentDescriptor;

.fi
.RE

.SH FLAGS AFFECTED
.PP
None

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If the current privilege level is not 0.
T}
	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the source operand contains a NULL segment selector.
T}
	T{
If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.
T}
#GP(selector)	T{
If the source selector points to a segment that is not a TSS or to one for a task that is already busy.
T}
	T{
If the selector points to LDT or is beyond the GDT limit.
T}
#NP(selector)	T{
If the TSS is marked not present.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault\-code)	If a page fault occurs.
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The LTR instruction is not recognized in real\-address mode.
T}
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The LTR instruction is not recognized in virtual\-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#SS(0)	T{
If a memory address referencing the SS segment is in a non\-canonical form.
T}
#GP(0)	T{
If the current privilege level is not 0.
T}
	T{
If the memory address is in a non\-canonical form.
T}
	T{
If the source operand contains a NULL segment selector.
T}
#GP(selector)	T{
If the source selector points to a segment that is not a TSS or to one for a task that is already busy.
T}
	T{
If the selector points to LDT or is beyond the GDT limit.
T}
	T{
If the descriptor type of the upper 8\-byte of the 16\-byte descriptor is non\-zero.
T}
#NP(selector)	T{
If the TSS is marked not present.
T}
#PF(fault\-code)	If a page fault occurs.
#UD	If the LOCK prefix is used.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
