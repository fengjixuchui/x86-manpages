.nh
.TH "X86-VERR-VERW" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VERR-VERW - VERIFY A SEGMENT FOR READING OR WRITING
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fCOp/En\fR	\fB\fC64\-Bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
0F 00 /4	VERR r/m16	M	Valid	Valid	T{
Set ZF=1 if segment specified with r/m16 can be read.
T}
0F 00 /5	VERW r/m16	M	Valid	Valid	T{
Set ZF=1 if segment specified with r/m16 can be written.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
M	ModRM:r/m (r)	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Verifies whether the code or data segment specified with the source
operand is readable (VERR) or writable (VERW) from the current privilege
level (CPL). The source operand is a 16\-bit register or a memory
location that contains the segment selector for the segment to be
verified. If the segment is accessible and readable (VERR) or writable
(VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code
segments are never verified as writable. This check cannot be performed
on system segments.

.PP
To set the ZF flag, the following conditions must be met:

.RS
.IP \(bu 2
The segment selector is not NULL.
.IP \(bu 2
The selector must denote a descriptor within the bounds of the
descriptor table (GDT or LDT).
.IP \(bu 2
The selector must denote the descriptor of a code or data segment
(not that of a system segment or gate).
.IP \(bu 2
For the VERR instruction, the segment must be readable.
.IP \(bu 2
For the VERW instruction, the segment must be a writable data
segment.
.IP \(bu 2
If the segment is not a conforming code segment, the segment’s DPL
must be greater than or equal to (have less or the same privilege
as) both the CPL and the segment selector's RPL.

.RE

.PP
The validation performed is the same as is performed when a segment
selector is loaded into the DS, ES, FS, or GS register, and the
indicated access (read or write) is performed. The segment selector's
value cannot result in a protection exception, enabling the software to
anticipate possible segment access problems.

.PP
This instruction’s operation is the same in non\-64\-bit modes and 64\-bit
mode. The operand size is fixed at 16 bits.

.SH OPERATION
.PP
.RS

.nf
IF SRC(Offset) > (GDTR(Limit) or (LDTR(Limit))
    THEN ZF ← 0; FI;
Read segment descriptor;
IF SegmentDescriptor(DescriptorType) = 0 (* System segment *)
or (SegmentDescriptor(Type) ≠ conforming code segment)
and (CPL > DPL) or (RPL > DPL)
    THEN
        ZF ← 0;
    ELSE
        IF ((Instruction = VERR) and (Segment readable))
        or ((Instruction = VERW) and (Segment writable))
            THEN
                ZF ← 1;
        FI;
FI;

.fi
.RE

.SH FLAGS AFFECTED
.PP
The ZF flag is set to 1 if the segment is accessible and readable (VERR)
or writable (VERW); otherwise, it is set to 0.

.SH PROTECTED MODE EXCEPTIONS
.PP
The only exceptions generated for these instructions are those related
to illegal addressing of the source operand.

.TS
allbox;
l l 
l l .
#GP(0)	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault\-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VERR and VERW instructions are not recognized in real\-address mode.
T}
	If the LOCK prefix is used.
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VERR and VERW instructions are not recognized in virtual\-8086 mode.
T}
	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#SS(0)	T{
If a memory address referencing the SS segment is in a non\-canonical form.
T}
#GP(0)	T{
If the memory address is in a non\-canonical form.
T}
#PF(fault\-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
