.nh
.TH "X86-AAD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
AAD - ASCII ADJUST AX BEFORE DIVISION
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fCOp/En\fR	\fB\fC64\-bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
D5 0A	AAD	ZO	Invalid	Valid	T{
ASCII adjust AX before division.
T}
D5 ib	AAD imm8	ZO	Invalid	Valid	T{
Adjust AX before division to number base imm8.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
ZO	NA	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Adjusts two unpacked BCD digits (the least\-significant digit in the AL
register and the most\-significant digit in the AH register) so that a
division operation performed on the result will yield a correct unpacked
BCD value. The AAD instruction is only useful when it precedes a DIV
instruction that divides (binary division) the adjusted value in the AX
register by an unpacked BCD value.

.PP
The AAD instruction sets the value in the AL register to (AL + (10 *
AH)), and then clears the AH register to 00H. The value in the AX
register is then equal to the binary equivalent of the original unpacked
two\-digit (base 10) number in registers AH and AL.

.PP
The generalized version of this instruction allows adjustment of two
unpacked digits of any number base (see the “Operation” section below),
by setting the imm8).

.PP
This instruction executes as described in compatibility mode and legacy
mode. It is not valid in 64\-bit mode.

.SH OPERATION
.PP
.RS

.nf
IF 64\-Bit Mode
    THEN
        #UD;
    ELSE
        tempAL ← AL;
        tempAH ← AH;
        AL ← (tempAL + (tempAH ∗ imm8)) AND FFH;
        (* imm8 is set to 0AH for the AAD mnemonic.*)
        AH ← 0;
FI;
The immediate value (imm8) is taken from the second byte of the instruction.

.fi
.RE

.SH FLAGS AFFECTED
.PP
The SF, ZF, and PF flags are set according to the resulting binary value
in the AL register; the OF, AF, and CF flags are undefined.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.PP
Same exceptions as protected mode.

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.PP
Same exceptions as protected mode.

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If in 64\-bit mode.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
