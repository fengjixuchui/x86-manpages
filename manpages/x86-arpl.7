.nh
.TH "X86-ARPL" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
ARPL - ADJUST RPL FIELD OF SEGMENT SELECTOR
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fCOp/En\fR	\fB\fC64\-bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
63 /r	ARPL r/m16, r16	MR	N. E.	Valid	Adjust RPL of r16.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
MR	ModRM:r/m (w)	ModRM:reg (r)	NA	NA
.TE

.SH DESCRIPTION
.PP
Compares the RPL fields of two segment selectors. The first operand (the
destination operand) contains one segment selector and the second
operand (source operand) contains the other. (The RPL field is located
in bits 0 and 1 of each operand.) If the RPL field of the destination
operand is less than the RPL field of the source operand, the ZF flag is
set and the RPL field of the destination operand is increased to match
that of the source operand. Otherwise, the ZF flag is cleared and no
change is made to the destination operand. (The destination operand can
be a word register or a memory location; the source operand must be a
word register.)

.PP
The ARPL instruction is provided for use by operating\-system procedures
(however, it can also be used by applications). It is generally used to
adjust the RPL of a segment selector that has been passed to the
operating system by an application program to match the privilege level
of the application program. Here the segment selector passed to the
operating system is placed in the destination operand and segment
selector for the application program’s code segment is placed in the
source operand. (The RPL field in the source operand represents the
privilege level of the application program.) Execution of the ARPL
instruction then ensures that the RPL of the segment selector received
by the operating system is no lower (does not have a higher privilege)
than the privilege level of the application program (the segment
selector for the application program’s code segment can be read from the
stack following a procedure call).

.PP
This instruction executes as described in compatibility mode and legacy
mode. It is not encodable in 64\-bit mode.

.PP
See “Checking Caller Access Privileges” in Chapter 3, “Protected\-Mode
Memory Management,” of the Intel® 64 and IA\-32 Architectures Software
Developer’s Manual, Volume 3A, for more information about the use of
this instruction.

.SH OPERATION
.PP
.RS

.nf
IF 64\-BIT MODE
    THEN
        See MOVSXD;
    ELSE
        IF DEST[RPL] < SRC[RPL]
            THEN
                ZF ← 1;
                DEST[RPL] ← SRC[RPL];
            ELSE
                ZF ← 0;
        FI;
FI;

.fi
.RE

.SH FLAGS AFFECTED
.PP
The ZF flag is set to 1 if the RPL field of the destination operand is
less than that of the source operand; otherwise, it is set to 0.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If the destination is located in a non\-writable segment.
T}
	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault\-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The ARPL instruction is not recognized in real\-address mode.
T}
	If the LOCK prefix is used.
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The ARPL instruction is not recognized in virtual\-8086 mode.
T}
	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.PP
Not applicable.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
