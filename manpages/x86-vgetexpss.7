.nh
.TH "X86-VGETEXPSS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VGETEXPSS - CONVERT EXPONENTS OF SCALAR SP FP VALUES TO SP FP VALUE
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
EVEX.LIG.66.0F38.W0 43 /r VGETEXPSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}
T}
	A	V/V	AVX512F	T{
Convert the biased exponent (bits 30:23) of the low single\-precision floating\-point value in xmm3/m32 to a SP FP value representing unbiased integer exponent. Stores the result to xmm1 under the writemask k1 and merge with the other elements of xmm2.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	Tuple1 Scalar	ModRM:reg (w)	EVEX.vvvv (r)	ModRM:r/m (r)	NA
.TE

.SS Description
.PP
Extracts the biased exponent from the normalized SP FP representation of
the low doubleword data element of the source operand (the third
operand) as unbiased signed integer value, or convert the denormal
representation of input data to unbiased negative integer values. The
integer value of the unbiased exponent is converted to single\-precision
FP value and written to the destination operand (the first operand) as
SP FP numbers. Bits (127:32) of the XMM register destination are copied
from corresponding bits in the first source operand.

.PP
The destination must be a XMM register, the source operand can be a XMM
register or a float32 memory location. The the low doubleword element of
the destination operand is conditionally updated with writemask k1.

.PP
Each GETEXP operation converts the exponent value into a FP number
(permitting input value in denormal representation). Special cases of
input values are listed in Table 5\-15.

.PP
The formula is:

.PP
GETEXP(x) = floor(log2(|x|))

.PP
Notation floor(x) stands for maximal integer not exceeding real number
x.

.PP
Software usage of VGETEXPxx and VGETMANTxx instructions generally
involve a combination of GETEXP operation and GETMANT operation (see
VGETMANTPD). Thus VGETEXPxx instruction do not require software to
handle SIMD FP exceptions.

.SS Operation
.PP
.RS

.nf
// NormalizeExpTinySPFP(SRC[31:0]) is defined in the Operation section of VGETEXPPS
// ConvertExpSPFP(SRC[31:0]) is defined in the Operation section of VGETEXPPS

.fi
.RE

.SS VGETEXPSS (EVEX encoded version)
.PP
.RS

.nf
IF k1[0] OR *no writemask*
    THEN DEST[31:0]←
            ConvertExpDPFP(SRC2[31:0])
    ELSE
        IF *merging\-masking*
                    ; merging\-masking
            THEN *DEST[31:0] remains unchanged*
            ELSE
                    ; zeroing\-masking
                DEST[31:0]← 0
            FI
    FI;
ENDFOR
DEST[127:32] ← SRC1[127:32]
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
VGETEXPSS \_\_m128 \_mm\_getexp\_ss( \_\_m128 a, \_\_m128 b);

VGETEXPSS \_\_m128 \_mm\_mask\_getexp\_ss(\_\_m128 s, \_\_mmask8 k, \_\_m128 a, \_\_m128 b);

VGETEXPSS \_\_m128 \_mm\_maskz\_getexp\_ss( \_\_mmask8 k, \_\_m128 a, \_\_m128 b);

VGETEXPSS \_\_m128 \_mm\_getexp\_round\_ss( \_\_m128 a, \_\_m128 b, int sae);

VGETEXPSS \_\_m128 \_mm\_mask\_getexp\_round\_ss(\_\_m128 s, \_\_mmask8 k, \_\_m128 a, \_\_m128 b, int sae);

VGETEXPSS \_\_m128 \_mm\_maskz\_getexp\_round\_ss( \_\_mmask8 k, \_\_m128 a, \_\_m128 b, int sae);

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
Invalid, Denormal

.SS Other Exceptions
.PP
See Exceptions Type E3.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
