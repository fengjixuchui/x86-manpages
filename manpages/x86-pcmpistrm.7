.nh
.TH "X86-PCMPISTRM" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
PCMPISTRM - PACKED COMPARE IMPLICIT LENGTH STRINGS, RETURN MASK
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
66 0F 3A 62 xmm1, xmm2/m128, imm8
T}
	RM	V/V	SSE4\_2	T{
Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
T}
T{
VEX.128.66.0F3A.WIG 62 /r ib VPCMPISTRM xmm1, xmm2/m128, imm8
T}
	RM	V/V	AVX	T{
Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RM	ModRM:reg (r)	ModRM:r/m (r)	imm8	NA
.TE

.SH DESCRIPTION
.PP
The instruction compares data from two strings based on the encoded
value in the imm8 byte (see Section 4.1, “Imm8 Control Byte Operation
for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”) generating a mask
stored to XMM0.

.PP
Each string is represented by a single value. The value is an xmm (or
possibly m128 for the second operand) which contains the data elements
of the string (byte or word data). Each input byte/word is augmented
with a valid/invalid tag. A byte/word is considered valid only if it has
a lower index than the least significant null byte/word. (The least
significant null byte/word is also considered invalid.)

.PP
The comparison and aggregation operation are performed according to the
encoded value of Imm8 bit fields (see Section 4.1). As defined by
imm8[6], IntRes2 is then either stored to the least significant bits
of XMM0 (zero extended to 128 bits) or expanded into a byte/word\-mask
and then stored to XMM0.

.PP
Note that the Arithmetic Flags are written in a non\-standard manner in
order to supply the most relevant information:

.PP
CFlag – Reset if IntRes2 is equal to zero, set otherwise

.PP
ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise

.PP
SFlag – Set if any byte/word of xmm1 is null, reset otherwise

.PP
OFlag – IntRes2[0]

.PP
AFlag – Reset

.PP
PFlag – Reset

.PP
Note: In VEX.128 encoded versions, bits (MAXVL\-1:128) of XMM0 are
zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0,
otherwise the instruction will #UD.

.SH EFFECTIVE OPERAND SIZE
.TS
allbox;
l l l l 
l l l l .
\fB\fCOperating mode/size\fR	\fB\fCOperand1\fR	\fB\fCOperand 2\fR	\fB\fCResult\fR
16 bit	xmm	xmm/m128	XMM0
32 bit	xmm	xmm/m128	XMM0
64 bit	xmm	xmm/m128	XMM0
.TE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT FOR RETURNING MASK
.PP
\_\_m128i \_mm\_cmpistrm (\_\_m128i a, \_\_m128i b, const int mode);

.SH INTEL C/C++ COMPILER INTRINSICS FOR READING EFLAG RESULTS
.PP
int \_mm\_cmpistra (\_\_m128i a, \_\_m128i b, const int mode);

.PP
int \_mm\_cmpistrc (\_\_m128i a, \_\_m128i b, const int mode);

.PP
int \_mm\_cmpistro (\_\_m128i a, \_\_m128i b, const int mode);

.PP
int \_mm\_cmpistrs (\_\_m128i a, \_\_m128i b, const int mode);

.PP
int \_mm\_cmpistrz (\_\_m128i a, \_\_m128i b, const int mode);

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None.

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4; additionally, this instruction does not cause
#GP if the memory operand is not aligned to 16 Byte boundary, and

.TS
allbox;
l l 
l l .
#UD	If VEX.L = 1.
	If VEX.vvvv ≠ 1111B.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
