.nh
.TH "X86-PCLMULQDQ" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
PCLMULQDQ - CARRY-LESS MULTIPLICATION QUADWORD
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
66 0F 3A 44 /r ib PCLMULQDQ xmm1, xmm2/m128, imm8
T}
	RMI	V/V	PCLMULQDQ	T{
Carry\-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128 should be used.
T}
T{
VEX.128.66.0F3A.WIG 44 /r ib VPCLMULQDQ xmm1, xmm2, xmm3/m128, imm8
T}
	RVMI	V/V	Both PCLMULQDQ and AVX flags	T{
Carry\-less multiplication of one quadword of xmm3/m128 should be used.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand2	Operand3	Operand4
RMI	ModRM:reg (r, w)	ModRM:r/m (r)	imm8	NA
RVMI	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	imm8
.TE

.SH DESCRIPTION
.PP
Performs a carry\-less multiplication of two quadwords, selected from the
first source and second source operand according to the value of the
immediate byte. Bits 4 and 0 are used to select which 64\-bit half of
each operand to use according to Table 4\-13, other bits of the immediate
byte are ignored.

.TS
allbox;
l l l 
l l l .
\fB\fCImm[4]\fR	\fB\fCImm[0]\fR	\fB\fCPCLMULQDQ Operation\fR
0	0	CL
\_
MUL( SRC21
[
63:0
]
, SRC1
[
63:0
]
 )
0	1	CL
\_
MUL( SRC2
[
63:0
]
, SRC1
[
127:64
]
 )
1	0	CL
\_
MUL( SRC2
[
127:64
]
, SRC1
[
63:0
]
 )
1	1	CL
\_
MUL( SRC2
[
127:64
]
, SRC1
[
127:64
]
 )
.TE

.PP
Table 4\-13. PCLMULQDQ Quadword Selection of Immediate Byte

.PP
.RS

.PP
1\&. SRC2 denotes the second source operand, which can be a register or
memory; SRC1 denotes the first source and destination operand.

.RE

.PP
The first source operand and the destination operand are the same and
must be an XMM register. The second source operand can be an XMM
register or a 128\-bit memory location. Bits (MAXVL\-1:128) of the
corresponding YMM destination register remain unchanged.

.PP
Compilers and assemblers may implement the following pseudo\-op syntax to
simply programming and emit the required encoding for Imm8.

.TS
allbox;
l l 
l l .
\fB\fCPseudo\-Op\fR	\fB\fCImm8 Encoding\fR
PCLMULLQLQDQ xmm1, xmm2	0000
\_
0000B
PCLMULHQLQDQ xmm1, xmm2	0000
\_
0001B
PCLMULLQHQDQ xmm1, xmm2	0001
\_
0000B
PCLMULHQHQDQ xmm1, xmm2	0001
\_
0001B
.TE

.PP
Table 4\-14. Pseudo\-Op and PCLMULQDQ Implementation

.SH OPERATION
.SS PCLMULQDQ
.PP
.RS

.nf
IF (Imm8[0] = 0 )
    THEN
        TEMP1←SRC1 [63:0];
    ELSE
        TEMP1←SRC1 [127:64];
FI
IF (Imm8[4] = 0 )
    THEN
        TEMP2←SRC2 [63:0];
    ELSE
        TEMP2←SRC2 [127:64];
FI
For i = 0 to 63 {
    TmpB [ i ]←(TEMP1[ 0 ] and TEMP2[ i ]);
    For j = 1 to i {
        TmpB [ i ]←TmpB [ i ] xor (TEMP1[ j ] and TEMP2[ i \- j ])
    }
    DEST[ i ]←TmpB[ i ];
}
For i = 64 to 126 {
    TmpB [ i ]←0;
    For j = i \- 63 to 63 {
        TmpB [ i ]←TmpB [ i ] xor (TEMP1[ j ] and TEMP2[ i \- j ])
    }
    DEST[ i ]←TmpB[ i ];
}
DEST[127] ← 0;
DEST[MAXVL\-1:128] (Unmodified)

.fi
.RE

.SS VPCLMULQDQ
.PP
.RS

.nf
IF (Imm8[0] = 0 )
    THEN
        TEMP1←SRC1 [63:0];
    ELSE
        TEMP1←SRC1 [127:64];
FI
IF (Imm8[4] = 0 )
    THEN
        TEMP2←SRC2 [63:0];
    ELSE
        TEMP2←SRC2 [127:64];
FI
For i = 0 to 63 {
    TmpB [ i ]←(TEMP1[ 0 ] and TEMP2[ i ]);
    For j = 1 to i {
        TmpB [i]←TmpB [i] xor (TEMP1[ j ] and TEMP2[ i \- j ])
    }
    DEST[i] ← TmpB[i];
}
For i = 64 to 126 {
    TmpB [ i ]←0;
    For j = i \- 63 to 63 {
        TmpB [i]←TmpB [i] xor (TEMP1[ j ] and TEMP2[ i \- j ])
    }
    DEST[i] ← TmpB[i];
}
DEST[MAXVL\-1:127] ← 0;

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
(V)PCLMULQDQ: \_\_m128i \_mm\_clmulepi64\_si128 (\_\_m128i, \_\_m128i, const int)

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None.

.SH OTHER EXCEPTIONS
.PP
See Exceptions Type 4, additionally

.TS
allbox;
l l 
l l .
#UD	If VEX.L = 1.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
