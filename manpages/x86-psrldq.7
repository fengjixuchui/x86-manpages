.nh
.TH "X86-PSRLDQ" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
PSRLDQ - SHIFT DOUBLE QUADWORD RIGHT LOGICAL
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
66 0F 73 /3 ib PSRLDQ imm8	A	V/V	SSE2	T{
Shift imm8 while shifting in 0s.
T}
T{
VEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2, imm8
T}
	B	V/V	AVX	T{
Shift imm8 bytes while shifting in 0s.
T}
T{
VEX.256.66.0F.WIG 73 /3 ib VPSRLDQ ymm1, ymm2, imm8
T}
	B	V/V	AVX2	T{
Shift imm8 bytes while shifting in 0s.
T}
T{
EVEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2/m128, imm8
T}
	C	V/V	AVX512VL AVX512BW	T{
Shift xmm2/m128 right by imm8 bytes while shifting in 0s and store result in xmm1.
T}
T{
EVEX.256.66.0F.WIG 73 /3 ib VPSRLDQ ymm1, ymm2/m256, imm8
T}
	C	V/V	AVX512VL AVX512BW	T{
Shift ymm2/m256 right by imm8 bytes while shifting in 0s and store result in ymm1.
T}
T{
EVEX.512.66.0F.WIG 73 /3 ib VPSRLDQ zmm1, zmm2/m512, imm8
T}
	C	V/V	AVX512BW	T{
Shift zmm2/m512 right by imm8 bytes while shifting in 0s and store result in zmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	NA	ModRM:r/m (r, w)	imm8	NA	NA
B	NA	VEX.vvvv (w)	ModRM:r/m (r)	imm8	NA
C	Full Mem	EVEX.vvvv (w)	ModRM:r/m (R)	Imm8	NA
.TE

.SH DESCRIPTION
.PP
Shifts the destination operand (first operand) to the right by the
number of bytes specified in the count operand (second operand). The
empty high\-order bytes are cleared (set to all 0s). If the value
specified by the count operand is greater than 15, the destination
operand is set to all 0s. The count operand is an 8\-bit immediate.

.PP
In 64\-bit mode and not encoded with VEX/EVEX, using a REX prefix in the
form of REX.R permits this instruction to access additional registers
(XMM8\-XMM15).

.PP
128\-bit Legacy SSE version: The source and destination operands are the
same. Bits (MAXVL\-1:128) of the corresponding YMM destination register
remain unchanged.

.PP
VEX.128 encoded version: The source and destination operands are XMM
registers. Bits (MAXVL\-1:128) of the destination YMM register are
zeroed.

.PP
VEX.256 encoded version: The source operand is a YMM register. The
destination operand is a YMM register. The count operand applies to both
the low and high 128\-bit lanes.

.PP
VEX.256 encoded version: The source operand is YMM register. The
destination operand is an YMM register. Bits (MAXVL\-1:256) of the
corresponding ZMM register are zeroed. The count operand applies to both
the low and high 128\-bit lanes.

.PP
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a
512/256/128\-bit memory location. The destination operand is a
ZMM/YMM/XMM register. The count operand applies to each 128\-bit lanes.

.PP
Note: VEX.vvvv/EVEX.vvvv encodes the destination register.

.SH OPERATION
.SS VPSRLDQ (EVEX.512 encoded version)
.PP
.RS

.nf
TEMP ← COUNT
IF (TEMP > 15) THEN TEMP←16; FI
DEST[127:0]←SRC[127:0] >> (TEMP * 8)
DEST[255:128]←SRC[255:128] >> (TEMP * 8)
DEST[383:256]←SRC[383:256] >> (TEMP * 8)
DEST[511:384]←SRC[511:384] >> (TEMP * 8)
DEST[MAXVL\-1:512] ← 0;

.fi
.RE

.SS VPSRLDQ (VEX.256 and EVEX.256 encoded version)
.PP
.RS

.nf
TEMP ← COUNT
IF (TEMP > 15) THEN TEMP←16; FI
DEST[127:0]←SRC[127:0] >> (TEMP * 8)
DEST[255:128]←SRC[255:128] >> (TEMP * 8)
DEST[MAXVL\-1:256] ← 0;

.fi
.RE

.SS VPSRLDQ (VEX.128 and EVEX.128 encoded version)
.PP
.RS

.nf
TEMP ← COUNT
IF (TEMP > 15) THEN TEMP←16; FI
DEST←SRC >> (TEMP * 8)
DEST[MAXVL\-1:128] ← 0;

.fi
.RE

.SS PSRLDQ(128\-bit Legacy SSE version)
.PP
.RS

.nf
TEMP ← COUNT
IF (TEMP > 15) THEN TEMP←16; FI
DEST←DEST >> (TEMP * 8)
DEST[MAXVL\-1:128] (Unmodified)

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENTS
.PP
.RS

.nf
(V)PSRLDQ \_\_m128i \_mm\_srli\_si128 ( \_\_m128i a, int imm)

VPSRLDQ \_\_m256i \_mm256\_bsrli\_epi128 ( \_\_m256i, const int)

VPSRLDQ \_\_m512i \_mm512\_bsrli\_epi128 ( \_\_m512i, int)

.fi
.RE

.SH FLAGS AFFECTED
.PP
None.

.SH NUMERIC EXCEPTIONS
.PP
None.

.SS Other Exceptions
.PP
Non\-EVEX\-encoded instruction, see Exceptions Type 7.

.PP
EVEX\-encoded instruction, see Exceptions Type E4NF.nb.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
