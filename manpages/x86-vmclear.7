.nh
.TH "X86-VMCLEAR" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VMCLEAR - CLEAR VIRTUAL-MACHINE CONTROL STRUCTURE
.TS
allbox;
l l l 
l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fCDescription\fR
66 0F C7 /6 VMCLEAR m64	M	T{
Copy VMCS data to VMCS region in memory.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
M	ModRM:r/m (r)	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
This instruction applies to the VMCS whose VMCS region resides at the
physical address contained in the instruction operand. The instruction
ensures that VMCS data for that VMCS (some of these data may be
currently maintained on the processor) are copied to the VMCS region in
memory. It also initializes parts of the VMCS region (for example, it
sets the launch state of that VMCS to clear). See Chapter 24,
“Virtual\-Machine Control Structures”.

.PP
The operand of this instruction is always 64 bits and is always in
memory. If the operand is the current\-VMCS pointer, then that pointer is
made invalid (set to FFFFFFFF\_FFFFFFFFH).

.PP
Note that the VMCLEAR instruction might not explicitly write any VMCS
data to memory; the data may be already resident in memory before the
VMCLEAR is executed.

.SH OPERATION
.PP
.RS

.nf
IF (register operand) or (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32\_EFER.LMA = 1 and CS.L = 0)
    THEN #UD;
ELSIF in VMX non\-root operation
    THEN VM exit;
ELSIF CPL > 0
    THEN #GP(0);
    ELSE
        addr ← contents of 64\-bit in\-memory operand;
        IF addr is not 4KB\-aligned OR
        addr sets any bits beyond the physical\-address width1
            THEN VMfail(VMCLEAR with invalid physical address);
        ELSIF addr = VMXON pointer
            THEN VMfail(VMCLEAR with VMXON pointer);
            ELSE
                ensure that data for VMCS referenced by the operand is in memory;
                initialize implementation\-specific data in VMCS region;
                launch state of VMCS referenced by the operand ← “clear”
                IF operand addr = current\-VMCS pointer
                    THEN current\-VMCS pointer ← FFFFFFFF\_FFFFFFFFH;
                FI;
                VMsucceed;
        FI;
FI;

.fi
.RE

.PP
.RS

.PP
1\&. If IA32\_VMX\_BASIC[48] is read as 1, VMfail occurs if addr sets
any bits in the range 63:32; see Appendix A.1.

.RE

.SH FLAGS AFFECTED
.PP
See the operation section and Section 30.2.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If the current privilege level is not 0.
T}
	T{
If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register contains an unusable segment.
T}
	T{
If the operand is located in an execute\-only code segment.
T}
#PF(fault\-code)	T{
If a page fault occurs in accessing the memory operand.
T}
#SS(0)	T{
If the memory operand effective address is outside the SS segment limit.
T}
	T{
If the SS register contains an unusable segment.
T}
#UD	If operand is a register.
	If not in VMX operation.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMCLEAR instruction is not recognized in real\-address mode.
T}
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMCLEAR instruction is not recognized in virtual\-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMCLEAR instruction is not recognized in compatibility mode.
T}
.TE

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If the current privilege level is not 0.
T}
	T{
If the source operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non\-canonical form.
T}
#PF(fault\-code)	T{
If a page fault occurs in accessing the memory operand.
T}
#SS(0)	T{
If the source operand is in the SS segment and the memory address is in a non\-canonical form.
T}
#UD	If operand is a register.
	If not in VMX operation.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
