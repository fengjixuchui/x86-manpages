.nh
.TH "X86-POPA-POPAD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
POPA-POPAD - POP ALL GENERAL-PURPOSE REGISTERS
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fCOp/En\fR	\fB\fC64\-Bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
61	POPA	ZO	Invalid	Valid	T{
Pop DI, SI, BP, BX, DX, CX, and AX.
T}
61	POPAD	ZO	Invalid	Valid	T{
Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
ZO	NA	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Pops doublewords (POPAD) or words (POPA) from the stack into the
general\-purpose registers. The registers are loaded in the following
order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand\-size
attribute is 32) and DI, SI, BP, BX, DX, CX, and AX (if the operand\-size
attribute is 16). (These instructions reverse the operation of the
PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP
register is ignored. Instead, the ESP or SP register is incremented
after each register is loaded.

.PP
The POPA (pop all) and POPAD (pop all double) mnemonics reference the
same opcode. The POPA instruction is intended for use when the
operand\-size attribute is 16 and the POPAD instruction for when the
operand\-size attribute is 32. Some assemblers may force the operand size
to 16 when POPA is used and to 32 when POPAD is used (using the
operand\-size override prefix [66H] if necessary). Others may treat
these mnemonics as synonyms (POPA/POPAD) and use the current setting of
the operand\-size attribute to determine the size of values to be popped
from the stack, regardless of the mnemonic used. (The D flag in the
current code segment’s segment descriptor determines the operand\-size
attribute.)

.PP
This instruction executes as described in non\-64\-bit modes. It is not
valid in 64\-bit mode.

.SH OPERATION
.PP
.RS

.nf
IF 64\-Bit Mode
    THEN
        #UD;
ELSE
    IF OperandSize = 32 (* Instruction = POPAD *)
    THEN
        EDI ← Pop();
        ESI ← Pop();
        EBP ← Pop();
        Increment ESP by 4; (* Skip next 4 bytes of stack *)
        EBX ← Pop();
        EDX ← Pop();
        ECX ← Pop();
        EAX ← Pop();
    ELSE (* OperandSize = 16, instruction = POPA *)
        DI ← Pop();
        SI ← Pop();
        BP ← Pop();
        Increment ESP by 2; (* Skip next 2 bytes of stack *)
        BX ← Pop();
        DX ← Pop();
        CX ← Pop();
        AX ← Pop();
    FI;
FI;

.fi
.RE

.SH FLAGS AFFECTED
.PP
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#SS(0)	T{
If the starting or ending stack address is not within the stack segment.
T}
#PF(fault\-code)	If a page fault occurs.
#AC(0)	T{
If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#SS	T{
If the starting or ending stack address is not within the stack segment.
T}
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#SS(0)	T{
If the starting or ending stack address is not within the stack segment.
T}
#PF(fault\-code)	If a page fault occurs.
#AC(0)	T{
If an unaligned memory reference is made while alignment checking is enabled.
T}
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same as for protected mode exceptions.

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If in 64\-bit mode.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
