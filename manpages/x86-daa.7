.nh
.TH "X86-DAA" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
DAA - DECIMAL ADJUST AL AFTER ADDITION
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fCOpcode\fR	\fB\fCInstruction\fR	\fB\fCOp/En\fR	\fB\fC64\-Bit Mode\fR	\fB\fCCompat/Leg Mode\fR	\fB\fCDescription\fR
27	DAA	ZO	Invalid	Valid	T{
Decimal adjust AL after addition.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
ZO	NA	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Adjusts the sum of two packed BCD values to create a packed BCD result.
The AL register is the implied source and destination operand. The DAA
instruction is only useful when it follows an ADD instruction that adds
(binary addition) two 2\-digit, packed BCD values and stores a byte
result in the AL register. The DAA instruction then adjusts the contents
of the AL register to contain the correct 2\-digit, packed BCD result. If
a decimal carry is detected, the CF and AF flags are set accordingly.

.PP
This instruction executes as described above in compatibility mode and
legacy mode. It is not valid in 64\-bit mode.

.SH OPERATION
.PP
.RS

.nf
IF 64\-Bit Mode
    THEN
        #UD;
    ELSE
        old\_AL ← AL;
        old\_CF ← CF;
        CF ← 0;
        IF (((AL AND 0FH) > 9) or AF = 1)
                THEN
                    AL ← AL + 6;
                    CF ← old\_CF or (Carry from AL ← AL + 6);
                    AF ← 1;
                ELSE
                    AF ← 0;
        FI;
        IF ((old\_AL > 99H) or (old\_CF = 1))
            THEN
                    AL ← AL + 60H;
                    CF ← 1;
            ELSE
                    CF ← 0;
        FI;
FI;

.fi
.RE

.SH EXAMPLE
.PP
ADD AL, BL Before: AL=79H BL=35H EFLAGS(OSZAPC)=XXXXXX After: AL=AEH
BL=35H EFLAGS(0SZAPC)=110000 DAA Before: AL=AEH BL=35H
EFLAGS(OSZAPC)=110000 After: AL=14H BL=35H EFLAGS(0SZAPC)=X00111 DAA
Before: AL=2EH BL=35H EFLAGS(OSZAPC)=110000 After: AL=34H BL=35H
EFLAGS(0SZAPC)=X00101

.SH FLAGS AFFECTED
.PP
The CF and AF flags are set if the adjustment of the value results in a
decimal carry in either digit of the result (see the “Operation” section
above). The SF, ZF, and PF flags are set according to the result. The OF
flag is undefined.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If the LOCK prefix is used.
.TE

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	If in 64\-bit mode.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
