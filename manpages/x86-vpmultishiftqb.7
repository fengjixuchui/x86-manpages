.nh
.TH "X86-VPMULTISHIFTQB" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VPMULTISHIFTQB - SELECT PACKED UNALIGNED BYTES FROM QUADWORD SOURCES
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode / Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
EVEX.128.66.0F38.W1 83 /r VPMULTISHIFTQB xmm1 {k1}{z}, xmm2,xmm3/m128/m64bcst
T}
	A	V/V	AVX512\_VBMI AVX512VL	T{
Select unaligned bytes from qwords in xmm3/m128/m64bcst using control bytes in xmm2, write byte results to xmm1 under k1.
T}
T{
EVEX.256.66.0F38.W1 83 /r VPMULTISHIFTQB ymm1 {k1}{z}, ymm2,ymm3/m256/m64bcst
T}
	A	V/V	AVX512\_VBMI AVX512VL	T{
Select unaligned bytes from qwords in ymm3/m256/m64bcst using control bytes in ymm2, write byte results to ymm1 under k1.
T}
T{
EVEX.512.66.0F38.W1 83 /r VPMULTISHIFTQB zmm1 {k1}{z}, zmm2,zmm3/m512/m64bcst
T}
	A	V/V	AVX512\_VBMI	T{
Select unaligned bytes from qwords in zmm3/m512/m64bcst using control bytes in zmm2, write byte results to zmm1 under k1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	Full	ModRM:reg (w)	EVEX.vvvv (r)	ModRM:r/m (r)	NA
.TE

.SS Description
.PP
This instruction selects eight unaligned bytes from each input qword
element of the second source operand (the third operand) and writes
eight assembled bytes for each qword element in the destination operand
(the first operand). Each byte result is selected using a byte\-granular
shift control within the corresponding qword element of the first source
operand (the second operand). Each byte result in the destination
operand is updated under the writemask k1.

.PP
Only the low 6 bits of each control byte are used to select an 8\-bit
slot to extract the output byte from the qword data in the second source
operand. The starting bit of the 8\-bit slot can be unaligned relative to
any byte boundary and is extracted from the input qword source at the
location specified in the low 6\-bit of the control byte. If the 8\-bit
slot would exceed the qword boundary, the out\-of\-bound portion of the
8\-bit slot is wrapped back to start from bit 0 of the input qword
element.

.PP
The first source operand is a ZMM/YMM/XMM register. The second source
operand can be a ZMM/YMM/XMM register, a 512/256/128\-bit memory location
or a 512/256/128\-bit vector broadcasted from a 64\-bit memory location.
The destination operand is a ZMM/YMM/XMM register.

.SS Operation
.SS VPMULTISHIFTQB DEST, SRC1, SRC2 (EVEX encoded version)
.PP
.RS

.nf
(KL, VL) = (2, 128),(4, 256), (8, 512)
FOR i ← 0 TO KL\-1
    IF EVEX.b=1 AND src2 is memory THEN
            tcur ← src2.qword[0]; //broadcasting
    ELSE
            tcur ← src2.qword[i];
    FI;
    FOR j ← 0 to 7
        ctrl ← src1.qword[i].byte[j] \& 63;
        FOR k ← 0 to 7
            res.bit[k] ← tcur.bit[ (ctrl+k) mod 64 ];
        ENDFOR
        IF k1[i*8+j] or no writemask THEN
            DEST.qword[i].byte[j] ← res;
        ELSE IF zeroing\-masking THEN
            DEST.qword[i].byte[j] ← 0;
    ENDFOR
ENDFOR
DEST.qword[MAX\_VL\-1:VL] ← 0;

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
VPMULTISHIFTQB \_\_m512i \_mm512\_multishift\_epi64\_epi8( \_\_m512i a, \_\_m512i b);

VPMULTISHIFTQB \_\_m512i \_mm512\_mask\_multishift\_epi64\_epi8(\_\_m512i s, \_\_mmask64 k, \_\_m512i a, \_\_m512i b);

VPMULTISHIFTQB \_\_m512i \_mm512\_maskz\_multishift\_epi64\_epi8( \_\_mmask64 k, \_\_m512i a, \_\_m512i b);

VPMULTISHIFTQB \_\_m256i \_mm256\_multishift\_epi64\_epi8( \_\_m256i a, \_\_m256i b);

VPMULTISHIFTQB \_\_m256i \_mm256\_mask\_multishift\_epi64\_epi8(\_\_m256i s, \_\_mmask32 k, \_\_m256i a, \_\_m256i b);

VPMULTISHIFTQB \_\_m256i \_mm256\_maskz\_multishift\_epi64\_epi8( \_\_mmask32 k, \_\_m256i a, \_\_m256i b);

VPMULTISHIFTQB \_\_m128i \_mm\_multishift\_epi64\_epi8( \_\_m128i a, \_\_m128i b);

VPMULTISHIFTQB \_\_m128i \_mm\_mask\_multishift\_epi64\_epi8(\_\_m128i s, \_\_mmask8 k, \_\_m128i a, \_\_m128i b);

VPMULTISHIFTQB \_\_m128i \_mm\_maskz\_multishift\_epi64\_epi8( \_\_mmask8 k, \_\_m128i a, \_\_m128i b);

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
None.

.SS Other Exceptions
.PP
See Exceptions Type E4NF.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
