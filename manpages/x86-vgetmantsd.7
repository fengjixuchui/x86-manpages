.nh
.TH "X86-VGETMANTSD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VGETMANTSD - EXTRACT FLOAT64 OF NORMALIZED MANTISSAS FROM FLOAT64 SCALAR
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
T{
EVEX.LIG.66.0F3A.W1 27 /r ib VGETMANTSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8
T}
	A	V/V	AVX512F	T{
Extract the normalized mantissa of the low float64 element in xmm3/m64 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
Op/En	Tuple Type	Operand 1	Operand 2	Operand 3	Operand 4
A	Tuple1 Scalar	ModRM:reg (w)	EVEX.vvvv (r)	ModRM:r/m (r)	NA
.TE

.SS Description
.PP
Convert the double\-precision floating values in the low quadword element
of the second source operand (the third operand) to DP FP value with the
mantissa normalization and sign control specified by the imm8 byte, see
Figure 5\-15. The converted result is written to the low quadword element
of the destination operand (the first operand) using writemask k1. Bits
(127:64) of the XMM register destination are copied from corresponding
bits in the first source operand. The normalized mantissa is specified
by interv (imm8[1:0]) and the sign control (sc) is specified by bits
3:2 of the immediate byte.

.PP
The conversion operation is:

.PP
k|x.significand|

.PP
where:

.PP
1 |x.significand| \&lt; 2

.PP
Unbiased exponent k depends on the interval range defined by interv and
whether the exponent of the source is even or odd. The sign of the final
result is determined by sc and the source sign.

.PP
If interv != 0 then k = \-1, otherwise K = 0. The encoded value of
imm8[1:0] and sign control are shown in

.PP
Figure 5\-15.

.PP
The converted DP FP result is encoded according to the sign control, the
unbiased exponent k (adding bias) and a mantissa normalized to the range
specified by interv.

.PP
The GetMant() function follows Table 5\-16 when dealing with
floating\-point special numbers.

.PP
This instruction is writemasked, so only those elements with the
corresponding bit set in vector mask register k1 are computed and stored
into zmm1. Elements in zmm1 with the corresponding bit clear in k1
retain their previous values.

.SS Operation
.PP
.RS

.nf
// GetNormalizeMantissaDP(SRC[63:0], SignCtrl[1:0], Interv[1:0]) is defined in the operation section of VGETMANTPD

.fi
.RE

.SS VGETMANTSD (EVEX encoded version)
.PP
.RS

.nf
SignCtrl[1:0] ← IMM8[3:2];
Interv[1:0] ← IMM8[1:0];
IF k1[0] OR *no writemask*
    THEN DEST[63:0]←
            GetNormalizedMantissaDP(SRC2[63:0], SignCtrl, Interv)
    ELSE
        IF *merging\-masking* ; merging\-masking
            THEN *DEST[63:0] remains unchanged*
            ELSE ; zeroing\-masking
                DEST[63:0] ← 0
        FI
FI;
DEST[127:64] ← SRC1[127:64]
DEST[MAXVL\-1:128] ← 0

.fi
.RE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.PP
.RS

.nf
VGETMANTSD \_\_m128d \_mm\_getmant\_sd( \_\_m128d a, \_\_m128 b, enum intv, enum sgn);

VGETMANTSD \_\_m128d \_mm\_mask\_getmant\_sd(\_\_m128d s, \_\_mmask8 k, \_\_m128d a, \_\_m128d b, enum intv, enum sgn);

VGETMANTSD \_\_m128d \_mm\_maskz\_getmant\_sd( \_\_mmask8 k, \_\_m128 a, \_\_m128d b, enum intv, enum sgn);

VGETMANTSD \_\_m128d \_mm\_getmant\_round\_sd( \_\_m128d a, \_\_m128 b, enum intv, enum sgn, int r);

VGETMANTSD \_\_m128d \_mm\_mask\_getmant\_round\_sd(\_\_m128d s, \_\_mmask8 k, \_\_m128d a, \_\_m128d b, enum intv, enum sgn, int r);

VGETMANTSD \_\_m128d \_mm\_maskz\_getmant\_round\_sd( \_\_mmask8 k, \_\_m128d a, \_\_m128d b, enum intv, enum sgn, int r);

.fi
.RE

.SS SIMD Floating\-Point Exceptions
.PP
Denormal, Invalid

.SS Other Exceptions
.PP
See Exceptions Type E3.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
