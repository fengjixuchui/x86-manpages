.nh
.TH "X86-BNDCU-BNDCN" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
BNDCU-BNDCN - CHECK UPPER BOUND
.TS
allbox;
l l l l l 
l l l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fC64/32 bit Mode Support\fR	\fB\fCCPUID Feature Flag\fR	\fB\fCDescription\fR
F2 0F 1A /r BNDCU bnd, r/m32	RM	NE/V	MPX	Generate a 
#
T{
BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form).
T}
F2 0F 1A /r BNDCU bnd, r/m64	RM	V/NE	MPX	Generate a 
#
T{
BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form).
T}
F2 0F 1B /r BNDCN bnd, r/m32	RM	NE/V	MPX	Generate a 
#
T{
BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form).
T}
F2 0F 1B /r BNDCN bnd, r/m64	RM	V/NE	MPX	Generate a 
#
T{
BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form).
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l 
l l l l .
Op/En	Operand 1	Operand 2	Operand 3
RM	ModRM:reg (w)	ModRM:r/m (r)	NA
.TE

.SH DESCRIPTION
.PP
Compare the address in the second operand with the upper bound in bnd.
The second operand can be either a register or a memory operand. If the
address is higher than the upper bound in bnd.UB, it will set BNDSTATUS
to 01H and signal a #BR exception.

.PP
BNDCU perform 1’s complement operation on the upper bound of bnd first
before proceeding with address comparison. BNDCN perform address
comparison directly using the upper bound in bnd that is already
reverted out of 1’s complement form.

.PP
This instruction does not cause any memory access, and does not read or
write any flags.

.PP
Effective address computation of m32/64 has identical behavior to LEA

.SH OPERATION
.SS BNDCU BND, reg
.PP
.RS

.nf
IF reg > NOT(BND.UB) Then
    BNDSTATUS ← 01H;
    #BR;
FI;

.fi
.RE

.SS BNDCU BND, mem
.PP
.RS

.nf
TEMP ← LEA(mem);
IF TEMP > NOT(BND.UB) Then
    BNDSTATUS ← 01H;
    #BR;
FI;

.fi
.RE

.SS BNDCN BND, reg
.PP
.RS

.nf
IF reg > BND.UB Then
    BNDSTATUS ← 01H;
    #BR;
FI;

.fi
.RE

.SS BNDCN BND, mem
.PP
.RS

.nf
TEMP ← LEA(mem);
IF TEMP > BND.UB Then
    BNDSTATUS ← 01H;
    #BR;
FI;

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
BNDCU .void \_bnd\_chk\_ptr\_ubounds(const void *q)

.fi
.RE

.SH FLAGS AFFECTED
.PP
None

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#BR	If upper bound check fails.
#UD	If the LOCK prefix is used.
	T{
If ModRM.r/m encodes BND4\-BND7 when Intel MPX is enabled.
T}
	T{
If 67H prefix is not used and CS.D=0.
T}
	T{
If 67H prefix is used and CS.D=1.
T}
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#BR	If upper bound check fails.
#UD	If the LOCK prefix is used.
	T{
If ModRM.r/m encodes BND4\-BND7 when Intel MPX is enabled.
T}
	If 16\-bit addressing is used.
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#BR	If upper bound check fails.
#UD	If the LOCK prefix is used.
	T{
If ModRM.r/m encodes BND4\-BND7 when Intel MPX is enabled.
T}
	If 16\-bit addressing is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
If ModRM.r/m and REX encodes BND4\-BND15 when Intel MPX is enabled.
T}
.TE

.PP
Same exceptions as in protected mode.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
