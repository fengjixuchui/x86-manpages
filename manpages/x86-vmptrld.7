.nh
.TH "X86-VMPTRLD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VMPTRLD - LOAD POINTER TO VIRTUAL-MACHINE CONTROL STRUCTURE
.TS
allbox;
l l l 
l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fCDescription\fR
NP 0F C7 /6 VMPTRLD m64	M	T{
Loads the current VMCS pointer from memory.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
M	ModRM:r/m (r)	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Marks the current\-VMCS pointer valid and loads it with the physical
address in the instruction operand. The instruction fails if its operand
is not properly aligned, sets unsupported physical\-address bits, or is
equal to the VMXON pointer. In addition, the instruction fails if the 32
bits in memory referenced by the operand do not match the VMCS revision
identifier supported by this processor.2

.PP
The operand of this instruction is always 64 bits and is always in
memory.

.SH OPERATION
.PP
.RS

.nf
IF (register operand) or (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32\_EFER.LMA = 1 and CS.L = 0)
    THEN #UD;
ELSIF in VMX non\-root operation
    THEN VMexit;
ELSIF CPL > 0
    THEN #GP(0);
    ELSE
        addr ← contents of 64\-bit in\-memory source operand;
        IF addr is not 4KB\-aligned OR
        addr sets any bits beyond the physical\-address width3
            THEN VMfail(VMPTRLD with invalid physical address);
        ELSIF addr = VMXON pointer
            THEN VMfail(VMPTRLD with VMXON pointer);
            ELSE
                rev ← 32 bits located at physical address addr;
                IF rev[30:0] ≠ VMCS revision identifier supported by processor OR
                rev[31] = 1 AND processor does not support 1\-setting of “VMCS shadowing”
                    THEN VMfail(VMPTRLD with incorrect VMCS revision identifier);
                    ELSE
                        current\-VMCS pointer ← addr;
                        VMsucceed;
                FI;
        FI;
FI;

.fi
.RE

.PP
.RS

.PP
2\&. Software should consult the VMX capability MSR VMX\_BASIC to
discover the VMCS revision identifier supported by this processor (see
Appendix A, “VMX Capability Reporting Facility”).

.PP
3\&. If IA32\_VMX\_BASIC[48] is read as 1, VMfail occurs if addr sets
any bits in the range 63:32; see Appendix A.1.

.RE

.SH FLAGS AFFECTED
.PP
See the operation section and Section 30.2.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If the current privilege level is not 0.
T}
	T{
If the memory source operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register contains an unusable segment.
T}
	T{
If the source operand is located in an execute\-only code segment.
T}
#PF(fault\-code)	T{
If a page fault occurs in accessing the memory source operand.
T}
#SS(0)	T{
If the memory source operand effective address is outside the SS segment limit.
T}
	T{
If the SS register contains an unusable segment.
T}
#UD	If operand is a register.
	If not in VMX operation.
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMPTRLD instruction is not recognized in real\-address mode.
T}
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMPTRLD instruction is not recognized in virtual\-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMPTRLD instruction is not recognized in compatibility mode.
T}
.TE

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If the current privilege level is not 0.
T}
	T{
If the source operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non\-canonical form.
T}
#PF(fault\-code)	T{
If a page fault occurs in accessing the memory source operand.
T}
#SS(0)	T{
If the source operand is in the SS segment and the memory address is in a non\-canonical form.
T}
#UD	If operand is a register.
	If not in VMX operation.
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
