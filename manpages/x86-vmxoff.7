.nh
.TH "X86-VMXOFF" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VMXOFF - LEAVE VMX OPERATION
.TS
allbox;
l l l 
l l l .
\fB\fCOpcode/Instruction\fR	\fB\fCOp/En\fR	\fB\fCDescription\fR
0F 01 C4 VMXOFF	ZO	Leaves VMX operation.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
ZO	NA	NA	NA	NA
.TE

.SH DESCRIPTION
.PP
Takes the logical processor out of VMX operation, unblocks INIT signals,
conditionally re\-enables A20M, and clears any address\-range monitoring.7

.SH OPERATION
.PP
.RS

.nf
IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32\_EFER.LMA = 1 and CS.L = 0)
    THEN #UD;
ELSIF in VMX non\-root operation
    THEN VMexit;
ELSIF CPL > 0
    THEN #GP(0);
ELSIF dual\-monitor treatment of SMIs and SMM is active
    THEN VMfail(VMXOFF under dual\-monitor treatment of SMIs and SMM);
    ELSE
        leave VMX operation;
        unblock INIT;
        IF IA32\_SMM\_MONITOR\_CTL[2] = 08
            THEN unblock SMIs;
        IF outside SMX operation9
            THEN unblock and enable A20M;
        FI;
        clear address\-range monitoring;
        VMsucceed;
FI;

.fi
.RE

.PP
.RS

.PP
7\&. See the information on MONITOR/MWAIT in Chapter 8,
“Multiple\-Processor Management,” of the Intel® 64 and IA\-32
Architectures Software Developer’s Manual, Volume 3A.

.PP
8\&. Setting IA32\_SMM\_MONITOR\_CTL[bit 2] to 1 prevents VMXOFF from
unblocking SMIs regardless of the value of the register’s value bit
(bit 0). Not all processors allow this bit to be set to 1. Software
should consult the VMX capability MSR IA32\_VMX\_MISC (see Appendix
A.6) to determine whether this is allowed.

.PP
9\&. A logical processor is outside SMX operation if GETSEC[SENTER]
has not been executed or if GETSEC[SEXIT] was executed after the
last execution of GETSEC[SENTER]\&. See Chapter 6, “Safer Mode
Extensions Reference.”

.RE

.SH FLAGS AFFECTED
.PP
See the operation section and Section 30.2.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If executed in VMX root operation with CPL 
T}
\&gt;
 0.
.TE

.TS
allbox;
l l 
l l .
#UD	T{
If executed outside VMX operation.
T}
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMXOFF instruction is not recognized in real\-address mode.
T}
.TE

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMXOFF instruction is not recognized in virtual\-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#UD	T{
The VMXOFF instruction is not recognized in compatibility mode.
T}
.TE

.SH 64\-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#GP(0)	T{
If executed in VMX root operation with CPL 
T}
\&gt;
 0.
#UD	T{
If executed outside VMX operation.
T}
.TE

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
Copyleft TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
