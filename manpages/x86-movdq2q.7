.nh
.TH "X86-MOVDQ2Q" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
MOVDQ2Q - MOVE QUADWORD FROM XMM TO MMX TECHNOLOGY REGISTER
.TS
allbox;
l 
l .
T{
Opcode Instruction Op/ 64\-Bit Compat/ Description En Mode Leg Mode F2 0F D6 /r MOVDQ2Q mmx register.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l 
l .
T{
Op/En Operand 1 Operand 2 Operand 3 Operand 4 RM ModRM:reg (w) ModRM:r/m (r) NA NA
T}
.TE

.SH DESCRIPTION
.PP
Moves the low quadword from the source operand (second operand) to the
destination operand (first operand). The source operand is an XMM
register and the destination operand is an MMX technology register.

.PP
This instruction causes a transition from x87 FPU to MMX technology
operation (that is, the x87 FPU top\-of\-stack pointer is set to 0 and the
x87 FPU tag word is set to all 0s [valid]). If this instruction is
executed while an x87 FPU floating\-point exception is pending, the
exception is handled before the MOVDQ2Q instruction is executed.

.PP
In 64\-bit mode, use of the REX.R prefix permits this instruction to
access additional registers (XMM8\-XMM15).

.SH OPERATION
.PP
.RS

.nf
DEST ← SRC[63:0];

.fi
.RE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.PP
.RS

.nf
MOVDQ2Q: \_\_m64 \_mm\_movepi64\_pi64 ( \_\_m128i a)

.fi
.RE

.SH SIMD FLOATING\-POINT EXCEPTIONS
.PP
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
#NM	If CR0.TS
[
bit 3
]
 = 1.
#UD	If CR0.EM
[
bit 2
]
 = 1.
	If CR4.OSFXSR
[
bit 9
]
 = 0.
	If CPUID.01H:EDX.SSE2
[
bit 26
]
 = 0.
	If the LOCK prefix is used.
#MF	T{
If there is a pending x87 FPU exception.
T}
.TE

.SH REAL\-ADDRESS MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH VIRTUAL\-8086 MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH COMPATIBILITY MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH 64\-BIT MODE EXCEPTIONS
.PP
Same exceptions as in protected mode.

.SH SEE ALSO
.PP
x86\-manpages(7) for a list of other x86\-64 man pages.

.SH COLOPHON
.PP
This UNOFFICIAL, mechanically\-separated, non\-verified reference is
provided for convenience, but it may be incomplete or broken in
various obvious or non\-obvious ways. Refer to Intel® 64 and IA\-32
Architectures Software Developer’s Manual for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2020 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
